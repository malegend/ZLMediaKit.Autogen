// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using IntPtr = global::System.IntPtr;

namespace ZLMediaKit
{
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void OnMkWebrtcGetAnswerSdp(IntPtr user_data, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string answer, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string err);

    public unsafe partial class MkConfig : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 64)]
        public partial struct __Internal
        {
            internal int thread_num;
            internal int log_level;
            internal int log_mask;
            internal IntPtr log_file_path;
            internal int log_file_days;
            internal int ini_is_path;
            internal IntPtr ini;
            internal int ssl_is_path;
            internal IntPtr ssl;
            internal IntPtr ssl_pwd;

            [SuppressUnmanagedCodeSecurity, DllImport("ZLMediaKit", EntryPoint = "??0mk_config@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr cctor(IntPtr __instance, IntPtr __0);
        }

        public IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ZLMediaKit.MkConfig> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ZLMediaKit.MkConfig>();

        private bool __log_file_path_OwnsNativeMemory = false;
        private bool __ini_OwnsNativeMemory = false;
        private bool __ssl_OwnsNativeMemory = false;
        private bool __ssl_pwd_OwnsNativeMemory = false;
        protected bool __ownsNativeInstance;

        internal static MkConfig __CreateInstance(IntPtr native, bool skipVTables = false)
        {
            return new MkConfig(native.ToPointer(), skipVTables);
        }

        internal static MkConfig __GetOrCreateInstance(IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (MkConfig)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static MkConfig __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new MkConfig(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private MkConfig(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MkConfig(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new IntPtr(native);
        }

        public MkConfig()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ZLMediaKit.MkConfig.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public MkConfig(global::ZLMediaKit.MkConfig __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ZLMediaKit.MkConfig.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ZLMediaKit.MkConfig.__Internal*)__Instance) = *((global::ZLMediaKit.MkConfig.__Internal*)__0.__Instance);
            if (__0.__log_file_path_OwnsNativeMemory)
                this.LogFilePath = __0.LogFilePath;
            if (__0.__ini_OwnsNativeMemory)
                this.Ini = __0.Ini;
            if (__0.__ssl_OwnsNativeMemory)
                this.Ssl = __0.Ssl;
            if (__0.__ssl_pwd_OwnsNativeMemory)
                this.SslPwd = __0.SslPwd;
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__log_file_path_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->log_file_path);
            if (__ini_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->ini);
            if (__ssl_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->ssl);
            if (__ssl_pwd_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->ssl_pwd);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int ThreadNum
        {
            get
            {
                return ((__Internal*)__Instance)->thread_num;
            }

            set
            {
                ((__Internal*)__Instance)->thread_num = value;
            }
        }

        public int LogLevel
        {
            get
            {
                return ((__Internal*)__Instance)->log_level;
            }

            set
            {
                ((__Internal*)__Instance)->log_level = value;
            }
        }

        public int LogMask
        {
            get
            {
                return ((__Internal*)__Instance)->log_mask;
            }

            set
            {
                ((__Internal*)__Instance)->log_mask = value;
            }
        }

        public string LogFilePath
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->log_file_path);
            }

            set
            {
                if (__log_file_path_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->log_file_path);
                __log_file_path_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->log_file_path = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->log_file_path = (IntPtr)__bytePtr0;
            }
        }

        public int LogFileDays
        {
            get
            {
                return ((__Internal*)__Instance)->log_file_days;
            }

            set
            {
                ((__Internal*)__Instance)->log_file_days = value;
            }
        }

        public int IniIsPath
        {
            get
            {
                return ((__Internal*)__Instance)->ini_is_path;
            }

            set
            {
                ((__Internal*)__Instance)->ini_is_path = value;
            }
        }

        public string Ini
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->ini);
            }

            set
            {
                if (__ini_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->ini);
                __ini_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->ini = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->ini = (IntPtr)__bytePtr0;
            }
        }

        public int SslIsPath
        {
            get
            {
                return ((__Internal*)__Instance)->ssl_is_path;
            }

            set
            {
                ((__Internal*)__Instance)->ssl_is_path = value;
            }
        }

        public string Ssl
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->ssl);
            }

            set
            {
                if (__ssl_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->ssl);
                __ssl_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->ssl = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->ssl = (IntPtr)__bytePtr0;
            }
        }

        public string SslPwd
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->ssl_pwd);
            }

            set
            {
                if (__ssl_pwd_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->ssl_pwd);
                __ssl_pwd_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->ssl_pwd = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->ssl_pwd = (IntPtr)__bytePtr0;
            }
        }
    }

    public unsafe partial class mk_common
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_env_init", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkEnvInit(IntPtr cfg);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_stop_all_server", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkStopAllServer();

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_env_init1", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkEnvInit1(int thread_num, int log_level, int log_mask, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string log_file_path, int log_file_days, int ini_is_path, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string ini, int ssl_is_path, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string ssl, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string ssl_pwd);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_set_log", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkSetLog(int file_max_size, int file_max_count);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_set_option", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkSetOption([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string key, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string val);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_get_option", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkGetOption([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string key);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_http_server_start", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ushort MkHttpServerStart(ushort port, int ssl);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_rtsp_server_start", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ushort MkRtspServerStart(ushort port, int ssl);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_rtmp_server_start", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ushort MkRtmpServerStart(ushort port, int ssl);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_rtp_server_start", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ushort MkRtpServerStart(ushort port);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_rtc_server_start", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ushort MkRtcServerStart(ushort port);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_webrtc_get_answer_sdp", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkWebrtcGetAnswerSdp(IntPtr user_data, IntPtr cb, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string type, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string offer, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string url);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_srt_server_start", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ushort MkSrtServerStart(ushort port);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_shell_server_start", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ushort MkShellServerStart(ushort port);
        }

        /// <summary>初始化环境，调用该库前需要先调用此函数</summary>
        /// <param name="cfg">库运行相关参数</param>
        public static void MkEnvInit(global::ZLMediaKit.MkConfig cfg)
        {
            var __arg0 = cfg is null ? IntPtr.Zero : cfg.__Instance;
            __Internal.MkEnvInit(__arg0);
        }

        /// <summary>关闭所有服务器，请在main函数退出时调用</summary>
        public static void MkStopAllServer()
        {
            __Internal.MkStopAllServer();
        }

        /// <summary>基础类型参数版本的mk_env_init，为了方便其他语言调用</summary>
        /// <param name="thread_num">线程数</param>
        /// <param name="log_level">日志级别,支持0~4</param>
        /// <param name="log_mask">日志输出方式掩模，请查看LOG_CONSOLE、LOG_FILE、LOG_CALLBACK等宏</param>
        /// <param name="log_file_path">文件日志保存路径,路径可以不存在(内部可以创建文件夹)，设置为NULL关闭日志输出至文件</param>
        /// <param name="log_file_days">文件日志保存天数,设置为0关闭日志文件</param>
        /// <param name="ini_is_path">配置文件是内容还是路径</param>
        /// <param name="ini">配置文件内容或路径，可以为NULL,如果该文件不存在，那么将导出默认配置至该文件</param>
        /// <param name="ssl_is_path">ssl证书是内容还是路径</param>
        /// <param name="ssl">ssl证书内容或路径，可以为NULL</param>
        /// <param name="ssl_pwd">证书密码，可以为NULL</param>
        public static void MkEnvInit1(int thread_num, int log_level, int log_mask, string log_file_path, int log_file_days, int ini_is_path, string ini, int ssl_is_path, string ssl, string ssl_pwd)
        {
            __Internal.MkEnvInit1(thread_num, log_level, log_mask, log_file_path, log_file_days, ini_is_path, ini, ssl_is_path, ssl, ssl_pwd);
        }

        /// <summary>设置日志文件</summary>
        /// <param name="file_max_size">单个切片文件大小(MB)</param>
        /// <param name="file_max_count">切片文件个数</param>
        public static void MkSetLog(int file_max_size, int file_max_count)
        {
            __Internal.MkSetLog(file_max_size, file_max_count);
        }

        /// <summary>设置配置项</summary>
        /// <param name="key">配置项名</param>
        /// <param name="val">配置项值</param>
        public static void MkSetOption(string key, string val)
        {
            __Internal.MkSetOption(key, val);
        }

        /// <summary>获取配置项的值</summary>
        /// <param name="key">配置项名</param>
        public static string MkGetOption(string key)
        {
            var __ret = __Internal.MkGetOption(key);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        /// <summary>创建http[s]服务器</summary>
        /// <param name="port">htt监听端口，推荐80，传入0则随机分配</param>
        /// <param name="ssl">是否为ssl类型服务器</param>
        /// <returns>0:失败,非0:端口号</returns>
        public static ushort MkHttpServerStart(ushort port, int ssl)
        {
            var __ret = __Internal.MkHttpServerStart(port, ssl);
            return __ret;
        }

        /// <summary>创建rtsp[s]服务器</summary>
        /// <param name="port">rtsp监听端口，推荐554，传入0则随机分配</param>
        /// <param name="ssl">是否为ssl类型服务器</param>
        /// <returns>0:失败,非0:端口号</returns>
        public static ushort MkRtspServerStart(ushort port, int ssl)
        {
            var __ret = __Internal.MkRtspServerStart(port, ssl);
            return __ret;
        }

        /// <summary>创建rtmp[s]服务器</summary>
        /// <param name="port">rtmp监听端口，推荐1935，传入0则随机分配</param>
        /// <param name="ssl">是否为ssl类型服务器</param>
        /// <returns>0:失败,非0:端口号</returns>
        public static ushort MkRtmpServerStart(ushort port, int ssl)
        {
            var __ret = __Internal.MkRtmpServerStart(port, ssl);
            return __ret;
        }

        /// <summary>创建rtp服务器</summary>
        /// <param name="port">rtp监听端口(包括udp/tcp)</param>
        /// <returns>0:失败,非0:端口号</returns>
        public static ushort MkRtpServerStart(ushort port)
        {
            var __ret = __Internal.MkRtpServerStart(port);
            return __ret;
        }

        /// <summary>创建rtc服务器</summary>
        /// <param name="port">rtc监听端口</param>
        /// <returns>0:失败,非0:端口号</returns>
        public static ushort MkRtcServerStart(ushort port)
        {
            var __ret = __Internal.MkRtcServerStart(port);
            return __ret;
        }

        /// <summary>webrtc交换sdp，根据offer sdp生成answer sdp</summary>
        /// <param name="user_data">回调用户指针</param>
        /// <param name="cb">回调函数</param>
        /// <param name="type">webrtc插件类型，支持echo,play,push</param>
        /// <param name="offer">webrtc offer sdp</param>
        /// <param name="url">rtc url, 例如 rtc://__defaultVhost/app/stream?key1=val1&amp;key2=val2</param>
        public static void MkWebrtcGetAnswerSdp(IntPtr user_data, global::ZLMediaKit.OnMkWebrtcGetAnswerSdp cb, string type, string offer, string url)
        {
            var __arg1 = cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cb);
            __Internal.MkWebrtcGetAnswerSdp(user_data, __arg1, type, offer, url);
        }

        /// <summary>创建srt服务器</summary>
        /// <param name="port">srt监听端口</param>
        /// <returns>0:失败,非0:端口号</returns>
        public static ushort MkSrtServerStart(ushort port)
        {
            var __ret = __Internal.MkSrtServerStart(port);
            return __ret;
        }

        /// <summary>创建shell服务器</summary>
        /// <param name="port">shell监听端口</param>
        /// <returns>0:失败,非0:端口号</returns>
        public static ushort MkShellServerStart(ushort port)
        {
            var __ret = __Internal.MkShellServerStart(port);
            return __ret;
        }
    }

    public unsafe partial class MkEvents : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 112)]
        public partial struct __Internal
        {
            internal IntPtr on_mk_media_changed;
            internal IntPtr on_mk_media_publish;
            internal IntPtr on_mk_media_play;
            internal IntPtr on_mk_media_not_found;
            internal IntPtr on_mk_media_no_reader;
            internal IntPtr on_mk_http_request;
            internal IntPtr on_mk_http_access;
            internal IntPtr on_mk_http_before_access;
            internal IntPtr on_mk_rtsp_get_realm;
            internal IntPtr on_mk_rtsp_auth;
            internal IntPtr on_mk_record_mp4;
            internal IntPtr on_mk_shell_login;
            internal IntPtr on_mk_flow_report;
            internal IntPtr on_mk_log;

            [SuppressUnmanagedCodeSecurity, DllImport("ZLMediaKit", EntryPoint = "??0mk_events@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr cctor(IntPtr __instance, IntPtr __0);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_events_listen", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkEventsListen(IntPtr events);
        }

        public IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ZLMediaKit.MkEvents> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ZLMediaKit.MkEvents>();

        protected bool __ownsNativeInstance;

        internal static MkEvents __CreateInstance(IntPtr native, bool skipVTables = false)
        {
            return new MkEvents(native.ToPointer(), skipVTables);
        }

        internal static MkEvents __GetOrCreateInstance(IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (MkEvents)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static MkEvents __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new MkEvents(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private MkEvents(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MkEvents(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new IntPtr(native);
        }

        public MkEvents()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ZLMediaKit.MkEvents.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public MkEvents(global::ZLMediaKit.MkEvents __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ZLMediaKit.MkEvents.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ZLMediaKit.MkEvents.__Internal*)__Instance) = *((global::ZLMediaKit.MkEvents.__Internal*)__0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>监听ZLMediaKit里面的事件</summary>
        /// <param name="events">各个事件的结构体,这个对象在内部会再拷贝一次，可以设置为null以便取消监听</param>
        public static void MkEventsListen(global::ZLMediaKit.MkEvents events)
        {
            var __arg0 = events is null ? IntPtr.Zero : events.__Instance;
            __Internal.MkEventsListen(__arg0);
        }

        /// <summary>注册或反注册MediaSource事件广播</summary>
        /// <param name="regist">注册为1，注销为0</param>
        /// <param name="sender">该MediaSource对象</param>
        public global::ZLMediaKit.Delegates.Action_int___IntPtr OnMkMediaChanged
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->on_mk_media_changed;
                return __ptr0 == IntPtr.Zero ? null : (global::ZLMediaKit.Delegates.Action_int___IntPtr)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::ZLMediaKit.Delegates.Action_int___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->on_mk_media_changed = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>收到rtsp/rtmp推流事件广播，通过该事件控制推流鉴权</summary>
        /// <param name="url_info">推流url相关信息</param>
        /// <param name="invoker">执行invoker返回鉴权结果</param>
        /// <param name="sender">该tcp客户端相关信息</param>
        /// <remarks>mk_publish_auth_invoker_do</remarks>
        public global::ZLMediaKit.Delegates.Action___IntPtr___IntPtr___IntPtr OnMkMediaPublish
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->on_mk_media_publish;
                return __ptr0 == IntPtr.Zero ? null : (global::ZLMediaKit.Delegates.Action___IntPtr___IntPtr___IntPtr)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::ZLMediaKit.Delegates.Action___IntPtr___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->on_mk_media_publish = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>播放rtsp/rtmp/http-flv/hls事件广播，通过该事件控制播放鉴权</summary>
        /// <param name="url_info">播放url相关信息</param>
        /// <param name="invoker">执行invoker返回鉴权结果</param>
        /// <param name="sender">播放客户端相关信息</param>
        /// <remarks>mk_auth_invoker_do</remarks>
        public global::ZLMediaKit.Delegates.Action___IntPtr___IntPtr___IntPtr OnMkMediaPlay
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->on_mk_media_play;
                return __ptr0 == IntPtr.Zero ? null : (global::ZLMediaKit.Delegates.Action___IntPtr___IntPtr___IntPtr)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::ZLMediaKit.Delegates.Action___IntPtr___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->on_mk_media_play = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>未找到流后会广播该事件，请在监听该事件后去拉流或其他方式产生流，这样就能按需拉流了</summary>
        /// <param name="url_info">播放url相关信息</param>
        /// <param name="sender">播放客户端相关信息</param>
        /// <returns>
        /// <para>1 直接关闭</para>
        /// <para>0 等待流注册</para>
        /// </returns>
        public global::ZLMediaKit.Delegates.Func_int___IntPtr___IntPtr OnMkMediaNotFound
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->on_mk_media_not_found;
                return __ptr0 == IntPtr.Zero ? null : (global::ZLMediaKit.Delegates.Func_int___IntPtr___IntPtr)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::ZLMediaKit.Delegates.Func_int___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->on_mk_media_not_found = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>某个流无人消费时触发，目的为了实现无人观看时主动断开拉流等业务逻辑</summary>
        /// <param name="sender">该MediaSource对象</param>
        public global::ZLMediaKit.Delegates.Action___IntPtr OnMkMediaNoReader
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->on_mk_media_no_reader;
                return __ptr0 == IntPtr.Zero ? null : (global::ZLMediaKit.Delegates.Action___IntPtr)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::ZLMediaKit.Delegates.Action___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->on_mk_media_no_reader = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>收到http api请求广播(包括GET/POST)</summary>
        /// <param name="parser">http请求内容对象</param>
        /// <param name="invoker">执行该invoker返回http回复</param>
        /// <param name="consumed">置1则说明我们要处理该事件</param>
        /// <param name="sender">http客户端相关信息</param>
        public global::ZLMediaKit.Delegates.Action___IntPtr___IntPtr_intPtr___IntPtr OnMkHttpRequest
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->on_mk_http_request;
                return __ptr0 == IntPtr.Zero ? null : (global::ZLMediaKit.Delegates.Action___IntPtr___IntPtr_intPtr___IntPtr)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::ZLMediaKit.Delegates.Action___IntPtr___IntPtr_intPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->on_mk_http_request = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>在http文件服务器中,收到http访问文件或目录的广播,通过该事件控制访问http目录的权限</summary>
        /// <param name="parser">http请求内容对象</param>
        /// <param name="path">文件绝对路径</param>
        /// <param name="is_dir">path是否为文件夹</param>
        /// <param name="invoker">执行invoker返回本次访问文件的结果</param>
        /// <param name="sender">http客户端相关信息</param>
        public global::ZLMediaKit.Delegates.Action___IntPtr_string8_int___IntPtr___IntPtr OnMkHttpAccess
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->on_mk_http_access;
                return __ptr0 == IntPtr.Zero ? null : (global::ZLMediaKit.Delegates.Action___IntPtr_string8_int___IntPtr___IntPtr)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::ZLMediaKit.Delegates.Action___IntPtr_string8_int___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->on_mk_http_access = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>
        /// <para>在http文件服务器中,收到http访问文件或目录前的广播,通过该事件可以控制http url到文件路径的映射</para>
        /// <para>在该事件中通过自行覆盖path参数，可以做到譬如根据虚拟主机或者app选择不同http根目录的目的</para>
        /// </summary>
        /// <param name="parser">http请求内容对象</param>
        /// <param name="path">文件绝对路径,覆盖之可以重定向到其他文件</param>
        /// <param name="sender">http客户端相关信息</param>
        public global::ZLMediaKit.Delegates.Action___IntPtr_sbytePtr___IntPtr OnMkHttpBeforeAccess
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->on_mk_http_before_access;
                return __ptr0 == IntPtr.Zero ? null : (global::ZLMediaKit.Delegates.Action___IntPtr_sbytePtr___IntPtr)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::ZLMediaKit.Delegates.Action___IntPtr_sbytePtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->on_mk_http_before_access = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>该rtsp流是否需要认证？是的话调用invoker并传入realm,否则传入空的realm</summary>
        /// <param name="url_info">请求rtsp url相关信息</param>
        /// <param name="invoker">执行invoker返回是否需要rtsp专属认证</param>
        /// <param name="sender">rtsp客户端相关信息</param>
        public global::ZLMediaKit.Delegates.Action___IntPtr___IntPtr___IntPtr OnMkRtspGetRealm
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->on_mk_rtsp_get_realm;
                return __ptr0 == IntPtr.Zero ? null : (global::ZLMediaKit.Delegates.Action___IntPtr___IntPtr___IntPtr)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::ZLMediaKit.Delegates.Action___IntPtr___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->on_mk_rtsp_get_realm = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>
        /// <para>请求认证用户密码事件，user_name为用户名，must_no_encrypt如果为true，则必须提供明文密码(因为此时是base64认证方式),否则会导致认证失败</para>
        /// <para>获取到密码后请调用invoker并输入对应类型的密码和密码类型，invoker执行时会匹配密码</para>
        /// </summary>
        /// <param name="url_info">请求rtsp url相关信息</param>
        /// <param name="realm">rtsp认证realm</param>
        /// <param name="user_name">rtsp认证用户名</param>
        /// <param name="must_no_encrypt">如果为true，则必须提供明文密码(因为此时是base64认证方式),否则会导致认证失败</param>
        /// <param name="invoker">执行invoker返回rtsp专属认证的密码</param>
        /// <param name="sender">rtsp客户端信息</param>
        public global::ZLMediaKit.Delegates.Action___IntPtr_string8_string8_int___IntPtr___IntPtr OnMkRtspAuth
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->on_mk_rtsp_auth;
                return __ptr0 == IntPtr.Zero ? null : (global::ZLMediaKit.Delegates.Action___IntPtr_string8_string8_int___IntPtr___IntPtr)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::ZLMediaKit.Delegates.Action___IntPtr_string8_string8_int___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->on_mk_rtsp_auth = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>录制mp4分片文件成功后广播</summary>
        public global::ZLMediaKit.Delegates.Action___IntPtr OnMkRecordMp4
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->on_mk_record_mp4;
                return __ptr0 == IntPtr.Zero ? null : (global::ZLMediaKit.Delegates.Action___IntPtr)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::ZLMediaKit.Delegates.Action___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->on_mk_record_mp4 = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>shell登录鉴权</summary>
        public global::ZLMediaKit.Delegates.Action_string8_string8___IntPtr___IntPtr OnMkShellLogin
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->on_mk_shell_login;
                return __ptr0 == IntPtr.Zero ? null : (global::ZLMediaKit.Delegates.Action_string8_string8___IntPtr___IntPtr)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::ZLMediaKit.Delegates.Action_string8_string8___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->on_mk_shell_login = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>停止rtsp/rtmp/http-flv会话后流量汇报事件广播</summary>
        /// <param name="url_info">播放url相关信息</param>
        /// <param name="total_bytes">耗费上下行总流量，单位字节数</param>
        /// <param name="total_seconds">本次tcp会话时长，单位秒</param>
        /// <param name="is_player">客户端是否为播放器</param>
        public global::ZLMediaKit.Delegates.Action___IntPtr_ulong_ulong_int___IntPtr OnMkFlowReport
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->on_mk_flow_report;
                return __ptr0 == IntPtr.Zero ? null : (global::ZLMediaKit.Delegates.Action___IntPtr_ulong_ulong_int___IntPtr)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::ZLMediaKit.Delegates.Action___IntPtr_ulong_ulong_int___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->on_mk_flow_report = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>日志输出广播</summary>
        /// <param name="level">日志级别</param>
        /// <param name="file">源文件名</param>
        /// <param name="line">源文件行</param>
        /// <param name="function">源文件函数名</param>
        /// <param name="message">日志内容</param>
        public global::ZLMediaKit.Delegates.Action_int_string8_int_string8_string8 OnMkLog
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->on_mk_log;
                return __ptr0 == IntPtr.Zero ? null : (global::ZLMediaKit.Delegates.Action_int_string8_int_string8_string8)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::ZLMediaKit.Delegates.Action_int_string8_int_string8_string8));
            }

            set
            {
                ((__Internal*)__Instance)->on_mk_log = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public enum MkTcpType
    {
        MkTypeTcp = 0,
        MkTypeSsl = 1,
        MkTypeWs = 2,
        MkTypeWss = 3
    }

    /// <summary>////////////////////////////////////////Buffer::Ptr/////////////////////////////////////////////</summary>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void OnMkBufferFree(IntPtr user_data, IntPtr data);

    /// <summary>////////////////////////////////////////SockInfo/////////////////////////////////////////////</summary>
    /// <summary>////////////////////////////////////////TcpSession/////////////////////////////////////////////</summary>
    /// <summary>////////////////////////////////////////自定义tcp服务/////////////////////////////////////////////</summary>
    /// <summary>////////////////////////////////////////自定义tcp客户端/////////////////////////////////////////////</summary>
    /// <summary>////////////////////////////////////////自定义tcp服务/////////////////////////////////////////////</summary>
    public unsafe partial class MkTcpSessionEvents : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal IntPtr on_mk_tcp_session_create;
            internal IntPtr on_mk_tcp_session_data;
            internal IntPtr on_mk_tcp_session_manager;
            internal IntPtr on_mk_tcp_session_disconnect;

            [SuppressUnmanagedCodeSecurity, DllImport("ZLMediaKit", EntryPoint = "??0mk_tcp_session_events@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr cctor(IntPtr __instance, IntPtr __0);
        }

        public IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ZLMediaKit.MkTcpSessionEvents> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ZLMediaKit.MkTcpSessionEvents>();

        protected bool __ownsNativeInstance;

        internal static MkTcpSessionEvents __CreateInstance(IntPtr native, bool skipVTables = false)
        {
            return new MkTcpSessionEvents(native.ToPointer(), skipVTables);
        }

        internal static MkTcpSessionEvents __GetOrCreateInstance(IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (MkTcpSessionEvents)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static MkTcpSessionEvents __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new MkTcpSessionEvents(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private MkTcpSessionEvents(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MkTcpSessionEvents(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new IntPtr(native);
        }

        public MkTcpSessionEvents()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ZLMediaKit.MkTcpSessionEvents.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public MkTcpSessionEvents(global::ZLMediaKit.MkTcpSessionEvents __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ZLMediaKit.MkTcpSessionEvents.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ZLMediaKit.MkTcpSessionEvents.__Internal*)__Instance) = *((global::ZLMediaKit.MkTcpSessionEvents.__Internal*)__0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>收到mk_tcp_session创建对象</summary>
        /// <param name="server_port">服务器端口号</param>
        /// <param name="session">会话处理对象</param>
        public global::ZLMediaKit.Delegates.Action_ushort___IntPtr OnMkTcpSessionCreate
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->on_mk_tcp_session_create;
                return __ptr0 == IntPtr.Zero ? null : (global::ZLMediaKit.Delegates.Action_ushort___IntPtr)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::ZLMediaKit.Delegates.Action_ushort___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->on_mk_tcp_session_create = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>收到客户端发过来的数据</summary>
        /// <param name="server_port">服务器端口号</param>
        /// <param name="session">会话处理对象</param>
        /// <param name="buffer">数据</param>
        public global::ZLMediaKit.Delegates.Action_ushort___IntPtr___IntPtr OnMkTcpSessionData
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->on_mk_tcp_session_data;
                return __ptr0 == IntPtr.Zero ? null : (global::ZLMediaKit.Delegates.Action_ushort___IntPtr___IntPtr)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::ZLMediaKit.Delegates.Action_ushort___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->on_mk_tcp_session_data = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>每隔2秒的定时器，用于管理超时等任务</summary>
        /// <param name="server_port">服务器端口号</param>
        /// <param name="session">会话处理对象</param>
        public global::ZLMediaKit.Delegates.Action_ushort___IntPtr OnMkTcpSessionManager
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->on_mk_tcp_session_manager;
                return __ptr0 == IntPtr.Zero ? null : (global::ZLMediaKit.Delegates.Action_ushort___IntPtr)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::ZLMediaKit.Delegates.Action_ushort___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->on_mk_tcp_session_manager = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>一般由于客户端断开tcp触发</summary>
        /// <param name="server_port">服务器端口号</param>
        /// <param name="session">会话处理对象</param>
        /// <param name="code">错误代码</param>
        /// <param name="msg">错误提示</param>
        public global::ZLMediaKit.Delegates.Action_ushort___IntPtr_int_string8 OnMkTcpSessionDisconnect
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->on_mk_tcp_session_disconnect;
                return __ptr0 == IntPtr.Zero ? null : (global::ZLMediaKit.Delegates.Action_ushort___IntPtr_int_string8)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::ZLMediaKit.Delegates.Action_ushort___IntPtr_int_string8));
            }

            set
            {
                ((__Internal*)__Instance)->on_mk_tcp_session_disconnect = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public unsafe partial class MkTcpClientEvents : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal IntPtr on_mk_tcp_client_connect;
            internal IntPtr on_mk_tcp_client_disconnect;
            internal IntPtr on_mk_tcp_client_data;
            internal IntPtr on_mk_tcp_client_manager;

            [SuppressUnmanagedCodeSecurity, DllImport("ZLMediaKit", EntryPoint = "??0mk_tcp_client_events@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr cctor(IntPtr __instance, IntPtr __0);
        }

        public IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ZLMediaKit.MkTcpClientEvents> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ZLMediaKit.MkTcpClientEvents>();

        protected bool __ownsNativeInstance;

        internal static MkTcpClientEvents __CreateInstance(IntPtr native, bool skipVTables = false)
        {
            return new MkTcpClientEvents(native.ToPointer(), skipVTables);
        }

        internal static MkTcpClientEvents __GetOrCreateInstance(IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (MkTcpClientEvents)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static MkTcpClientEvents __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new MkTcpClientEvents(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private MkTcpClientEvents(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MkTcpClientEvents(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new IntPtr(native);
        }

        public MkTcpClientEvents()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ZLMediaKit.MkTcpClientEvents.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public MkTcpClientEvents(global::ZLMediaKit.MkTcpClientEvents __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ZLMediaKit.MkTcpClientEvents.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ZLMediaKit.MkTcpClientEvents.__Internal*)__Instance) = *((global::ZLMediaKit.MkTcpClientEvents.__Internal*)__0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>tcp客户端连接服务器成功或失败回调</summary>
        /// <param name="client">tcp客户端</param>
        /// <param name="code">0为连接成功，否则为失败原因</param>
        /// <param name="msg">连接失败错误提示</param>
        public global::ZLMediaKit.Delegates.Action___IntPtr_int_string8 OnMkTcpClientConnect
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->on_mk_tcp_client_connect;
                return __ptr0 == IntPtr.Zero ? null : (global::ZLMediaKit.Delegates.Action___IntPtr_int_string8)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::ZLMediaKit.Delegates.Action___IntPtr_int_string8));
            }

            set
            {
                ((__Internal*)__Instance)->on_mk_tcp_client_connect = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>
        /// <para>tcp客户端与tcp服务器之间断开回调</para>
        /// <para>一般是eof事件导致</para>
        /// </summary>
        /// <param name="client">tcp客户端</param>
        /// <param name="code">错误代码</param>
        /// <param name="msg">错误提示</param>
        public global::ZLMediaKit.Delegates.Action___IntPtr_int_string8 OnMkTcpClientDisconnect
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->on_mk_tcp_client_disconnect;
                return __ptr0 == IntPtr.Zero ? null : (global::ZLMediaKit.Delegates.Action___IntPtr_int_string8)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::ZLMediaKit.Delegates.Action___IntPtr_int_string8));
            }

            set
            {
                ((__Internal*)__Instance)->on_mk_tcp_client_disconnect = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>收到tcp服务器发来的数据</summary>
        /// <param name="client">tcp客户端</param>
        /// <param name="buffer">数据</param>
        public global::ZLMediaKit.Delegates.Action___IntPtr___IntPtr OnMkTcpClientData
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->on_mk_tcp_client_data;
                return __ptr0 == IntPtr.Zero ? null : (global::ZLMediaKit.Delegates.Action___IntPtr___IntPtr)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::ZLMediaKit.Delegates.Action___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->on_mk_tcp_client_data = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>每隔2秒的定时器，用于管理超时等任务</summary>
        /// <param name="client">tcp客户端</param>
        public global::ZLMediaKit.Delegates.Action___IntPtr OnMkTcpClientManager
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->on_mk_tcp_client_manager;
                return __ptr0 == IntPtr.Zero ? null : (global::ZLMediaKit.Delegates.Action___IntPtr)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::ZLMediaKit.Delegates.Action___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->on_mk_tcp_client_manager = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public unsafe partial class mk_tcp
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_buffer_from_char", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkBufferFromChar([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string data, ulong len, IntPtr cb, IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_buffer_ref", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkBufferRef(IntPtr buffer);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_buffer_unref", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkBufferUnref(IntPtr buffer);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_buffer_get_data", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkBufferGetData(IntPtr buffer);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_buffer_get_size", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ulong MkBufferGetSize(IntPtr buffer);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_sock_info_peer_ip", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkSockInfoPeerIp(IntPtr ctx, sbyte* buf);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_sock_info_local_ip", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkSockInfoLocalIp(IntPtr ctx, sbyte* buf);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_sock_info_peer_port", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ushort MkSockInfoPeerPort(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_sock_info_local_port", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ushort MkSockInfoLocalPort(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_tcp_session_get_sock_info", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkTcpSessionGetSockInfo(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_tcp_session_shutdown", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkTcpSessionShutdown(IntPtr ctx, int err, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string err_msg);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_tcp_session_send", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkTcpSessionSend(IntPtr ctx, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string data, ulong len);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_tcp_session_send_buffer", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkTcpSessionSendBuffer(IntPtr ctx, IntPtr buffer);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_tcp_session_send_safe", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkTcpSessionSendSafe(IntPtr ctx, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string data, ulong len);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_tcp_session_send_buffer_safe", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkTcpSessionSendBufferSafe(IntPtr ctx, IntPtr buffer);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_tcp_session_ref_from", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkTcpSessionRefFrom(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_tcp_session_ref_release", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkTcpSessionRefRelease(IntPtr @ref);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_tcp_session_from_ref", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkTcpSessionFromRef(IntPtr @ref);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_tcp_session_set_user_data", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkTcpSessionSetUserData(IntPtr session, IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_tcp_session_get_user_data", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkTcpSessionGetUserData(IntPtr session);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_tcp_server_start", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ushort MkTcpServerStart(ushort port, global::ZLMediaKit.MkTcpType type);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_tcp_server_events_listen", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkTcpServerEventsListen(IntPtr events);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_tcp_client_get_sock_info", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkTcpClientGetSockInfo(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_tcp_client_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkTcpClientCreate(IntPtr events, global::ZLMediaKit.MkTcpType type);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_tcp_client_release", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkTcpClientRelease(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_tcp_client_connect", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkTcpClientConnect(IntPtr ctx, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string host, ushort port, float time_out_sec);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_tcp_client_send", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkTcpClientSend(IntPtr ctx, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string data, int len);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_tcp_client_send_buffer", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkTcpClientSendBuffer(IntPtr ctx, IntPtr buffer);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_tcp_client_send_safe", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkTcpClientSendSafe(IntPtr ctx, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string data, int len);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_tcp_client_send_buffer_safe", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkTcpClientSendBufferSafe(IntPtr ctx, IntPtr buffer);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_tcp_client_set_user_data", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkTcpClientSetUserData(IntPtr ctx, IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_tcp_client_get_user_data", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkTcpClientGetUserData(IntPtr ctx);
        }

        /// <summary>创建buffer对象</summary>
        /// <param name="data">数据指针</param>
        /// <param name="len">数据长度</param>
        /// <param name="cb">数据指针free回调函数，该参数置空时，内部会拷贝数据</param>
        /// <param name="user_data">数据指针free回调函数on_mk_buffer_free第一个参数</param>
        /// <returns>buffer对象</returns>
        public static IntPtr MkBufferFromChar(string data, ulong len, global::ZLMediaKit.OnMkBufferFree cb, IntPtr user_data)
        {
            var __arg2 = cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cb);
            var __ret = __Internal.MkBufferFromChar(data, len, __arg2, user_data);
            return __ret;
        }

        public static IntPtr MkBufferRef(IntPtr buffer)
        {
            var __ret = __Internal.MkBufferRef(buffer);
            return __ret;
        }

        public static void MkBufferUnref(IntPtr buffer)
        {
            __Internal.MkBufferUnref(buffer);
        }

        public static string MkBufferGetData(IntPtr buffer)
        {
            var __ret = __Internal.MkBufferGetData(buffer);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static ulong MkBufferGetSize(IntPtr buffer)
        {
            var __ret = __Internal.MkBufferGetSize(buffer);
            return __ret;
        }

        public static string MkSockInfoPeerIp(IntPtr ctx, sbyte* buf)
        {
            var __ret = __Internal.MkSockInfoPeerIp(ctx, buf);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static string MkSockInfoLocalIp(IntPtr ctx, sbyte* buf)
        {
            var __ret = __Internal.MkSockInfoLocalIp(ctx, buf);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static ushort MkSockInfoPeerPort(IntPtr ctx)
        {
            var __ret = __Internal.MkSockInfoPeerPort(ctx);
            return __ret;
        }

        public static ushort MkSockInfoLocalPort(IntPtr ctx)
        {
            var __ret = __Internal.MkSockInfoLocalPort(ctx);
            return __ret;
        }

        public static IntPtr MkTcpSessionGetSockInfo(IntPtr ctx)
        {
            var __ret = __Internal.MkTcpSessionGetSockInfo(ctx);
            return __ret;
        }

        public static void MkTcpSessionShutdown(IntPtr ctx, int err, string err_msg)
        {
            __Internal.MkTcpSessionShutdown(ctx, err, err_msg);
        }

        public static void MkTcpSessionSend(IntPtr ctx, string data, ulong len)
        {
            __Internal.MkTcpSessionSend(ctx, data, len);
        }

        public static void MkTcpSessionSendBuffer(IntPtr ctx, IntPtr buffer)
        {
            __Internal.MkTcpSessionSendBuffer(ctx, buffer);
        }

        public static void MkTcpSessionSendSafe(IntPtr ctx, string data, ulong len)
        {
            __Internal.MkTcpSessionSendSafe(ctx, data, len);
        }

        public static void MkTcpSessionSendBufferSafe(IntPtr ctx, IntPtr buffer)
        {
            __Internal.MkTcpSessionSendBufferSafe(ctx, buffer);
        }

        public static IntPtr MkTcpSessionRefFrom(IntPtr ctx)
        {
            var __ret = __Internal.MkTcpSessionRefFrom(ctx);
            return __ret;
        }

        public static void MkTcpSessionRefRelease(IntPtr @ref)
        {
            __Internal.MkTcpSessionRefRelease(@ref);
        }

        public static IntPtr MkTcpSessionFromRef(IntPtr @ref)
        {
            var __ret = __Internal.MkTcpSessionFromRef(@ref);
            return __ret;
        }

        /// <summary>
        /// <para>tcp会话对象附着用户数据</para>
        /// <para>该函数只对mk_tcp_server_server_start启动的服务类型有效</para>
        /// </summary>
        /// <param name="session">会话对象</param>
        /// <param name="user_data">用户数据指针</param>
        public static void MkTcpSessionSetUserData(IntPtr session, IntPtr user_data)
        {
            __Internal.MkTcpSessionSetUserData(session, user_data);
        }

        /// <summary>
        /// <para>获取tcp会话对象上附着的用户数据</para>
        /// <para>该函数只对mk_tcp_server_server_start启动的服务类型有效</para>
        /// </summary>
        /// <param name="session">tcp会话对象</param>
        /// <returns>用户数据指针</returns>
        public static IntPtr MkTcpSessionGetUserData(IntPtr session)
        {
            var __ret = __Internal.MkTcpSessionGetUserData(session);
            return __ret;
        }

        /// <summary>开启tcp服务器</summary>
        /// <param name="port">监听端口号，0则为随机</param>
        /// <param name="type">服务器类型</param>
        public static ushort MkTcpServerStart(ushort port, global::ZLMediaKit.MkTcpType type)
        {
            var __ret = __Internal.MkTcpServerStart(port, type);
            return __ret;
        }

        /// <summary>监听tcp服务器事件</summary>
        public static void MkTcpServerEventsListen(global::ZLMediaKit.MkTcpSessionEvents events)
        {
            var __arg0 = events is null ? IntPtr.Zero : events.__Instance;
            __Internal.MkTcpServerEventsListen(__arg0);
        }

        public static IntPtr MkTcpClientGetSockInfo(IntPtr ctx)
        {
            var __ret = __Internal.MkTcpClientGetSockInfo(ctx);
            return __ret;
        }

        /// <summary>创建tcp客户端</summary>
        /// <param name="events">回调函数结构体</param>
        /// <param name="user_data">用户数据指针</param>
        /// <param name="type">客户端类型</param>
        /// <returns>客户端对象</returns>
        public static IntPtr MkTcpClientCreate(global::ZLMediaKit.MkTcpClientEvents events, global::ZLMediaKit.MkTcpType type)
        {
            var __arg0 = events is null ? IntPtr.Zero : events.__Instance;
            var __ret = __Internal.MkTcpClientCreate(__arg0, type);
            return __ret;
        }

        /// <summary>释放tcp客户端</summary>
        /// <param name="ctx">客户端对象</param>
        public static void MkTcpClientRelease(IntPtr ctx)
        {
            __Internal.MkTcpClientRelease(ctx);
        }

        /// <summary>发起连接</summary>
        /// <param name="ctx">客户端对象</param>
        /// <param name="host">服务器ip或域名</param>
        /// <param name="port">服务器端口号</param>
        /// <param name="time_out_sec">超时时间</param>
        public static void MkTcpClientConnect(IntPtr ctx, string host, ushort port, float time_out_sec)
        {
            __Internal.MkTcpClientConnect(ctx, host, port, time_out_sec);
        }

        /// <summary>
        /// <para>非线程安全的发送数据</para>
        /// <para>开发者如果能确保在本对象网络线程内，可以调用此此函数</para>
        /// </summary>
        /// <param name="ctx">客户端对象</param>
        /// <param name="data">数据指针</param>
        /// <param name="len">数据长度，等于0时，内部通过strlen获取</param>
        public static void MkTcpClientSend(IntPtr ctx, string data, int len)
        {
            __Internal.MkTcpClientSend(ctx, data, len);
        }

        public static void MkTcpClientSendBuffer(IntPtr ctx, IntPtr buffer)
        {
            __Internal.MkTcpClientSendBuffer(ctx, buffer);
        }

        /// <summary>切换到本对象的网络线程后再发送数据</summary>
        /// <param name="ctx">客户端对象</param>
        /// <param name="data">数据指针</param>
        /// <param name="len">数据长度，等于0时，内部通过strlen获取</param>
        public static void MkTcpClientSendSafe(IntPtr ctx, string data, int len)
        {
            __Internal.MkTcpClientSendSafe(ctx, data, len);
        }

        public static void MkTcpClientSendBufferSafe(IntPtr ctx, IntPtr buffer)
        {
            __Internal.MkTcpClientSendBufferSafe(ctx, buffer);
        }

        /// <summary>客户端附着用户数据</summary>
        /// <param name="ctx">客户端对象</param>
        /// <param name="user_data">用户数据指针</param>
        public static void MkTcpClientSetUserData(IntPtr ctx, IntPtr user_data)
        {
            __Internal.MkTcpClientSetUserData(ctx, user_data);
        }

        /// <summary>获取客户端对象上附着的用户数据</summary>
        /// <param name="ctx">客户端对象</param>
        /// <returns>用户数据指针</returns>
        public static IntPtr MkTcpClientGetUserData(IntPtr ctx)
        {
            var __ret = __Internal.MkTcpClientGetUserData(ctx);
            return __ret;
        }
    }

    /// <summary>////////////////////////////////////////MP4Info/////////////////////////////////////////////</summary>
    /// <summary>////////////////////////////////////////Parser/////////////////////////////////////////////</summary>
    /// <summary>////////////////////////////////////////MediaInfo/////////////////////////////////////////////</summary>
    /// <summary>////////////////////////////////////////MediaSource/////////////////////////////////////////////</summary>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void OnMkMediaSourceFindCb(IntPtr user_data, IntPtr ctx);

    /// <summary>rtp推流成功与否的回调(第一次成功后，后面将一直重试)</summary>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void OnMkMediaSourceSendRtpResult(IntPtr user_data, ushort local_port, int err, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string msg);

    /// <summary>////////////////////////////////////////HttpBody/////////////////////////////////////////////</summary>
    /// <summary>////////////////////////////////////////HttpResponseInvoker/////////////////////////////////////////////</summary>
    /// <summary>////////////////////////////////////////HttpAccessPathInvoker/////////////////////////////////////////////</summary>
    /// <summary>////////////////////////////////////////RtspSession::onGetRealm/////////////////////////////////////////////</summary>
    /// <summary>////////////////////////////////////////RtspSession::onAuth/////////////////////////////////////////////</summary>
    /// <summary>////////////////////////////////////////Broadcast::PublishAuthInvoker/////////////////////////////////////////////</summary>
    /// <summary>////////////////////////////////////////Broadcast::AuthInvoker/////////////////////////////////////////////</summary>
    public unsafe partial class mk_events_objects
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_mp4_info_get_start_time", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ulong MkMp4InfoGetStartTime(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_mp4_info_get_time_len", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern float MkMp4InfoGetTimeLen(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_mp4_info_get_file_size", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ulong MkMp4InfoGetFileSize(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_mp4_info_get_file_path", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkMp4InfoGetFilePath(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_mp4_info_get_file_name", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkMp4InfoGetFileName(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_mp4_info_get_folder", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkMp4InfoGetFolder(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_mp4_info_get_url", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkMp4InfoGetUrl(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_mp4_info_get_vhost", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkMp4InfoGetVhost(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_mp4_info_get_app", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkMp4InfoGetApp(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_mp4_info_get_stream", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkMp4InfoGetStream(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_parser_get_method", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkParserGetMethod(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_parser_get_url", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkParserGetUrl(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_parser_get_url_params", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkParserGetUrlParams(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_parser_get_url_param", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkParserGetUrlParam(IntPtr ctx, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string key);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_parser_get_tail", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkParserGetTail(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_parser_get_header", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkParserGetHeader(IntPtr ctx, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string key);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_parser_get_content", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkParserGetContent(IntPtr ctx, ulong* length);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_media_info_get_params", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkMediaInfoGetParams(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_media_info_get_schema", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkMediaInfoGetSchema(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_media_info_get_vhost", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkMediaInfoGetVhost(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_media_info_get_app", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkMediaInfoGetApp(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_media_info_get_stream", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkMediaInfoGetStream(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_media_info_get_host", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkMediaInfoGetHost(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_media_info_get_port", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ushort MkMediaInfoGetPort(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_media_source_get_schema", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkMediaSourceGetSchema(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_media_source_get_vhost", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkMediaSourceGetVhost(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_media_source_get_app", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkMediaSourceGetApp(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_media_source_get_stream", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkMediaSourceGetStream(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_media_source_get_reader_count", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int MkMediaSourceGetReaderCount(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_media_source_get_total_reader_count", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int MkMediaSourceGetTotalReaderCount(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_media_source_close", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int MkMediaSourceClose(IntPtr ctx, int force);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_media_source_seek_to", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int MkMediaSourceSeekTo(IntPtr ctx, uint stamp);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_media_source_start_send_rtp", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkMediaSourceStartSendRtp(IntPtr ctx, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string dst_url, ushort dst_port, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string ssrc, int is_udp, IntPtr cb, IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_media_source_stop_send_rtp", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int MkMediaSourceStopSendRtp(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_media_source_find", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkMediaSourceFind([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string schema, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string vhost, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string app, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string stream, int from_mp4, IntPtr user_data, IntPtr cb);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_media_source_for_each", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkMediaSourceForEach(IntPtr user_data, IntPtr cb, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string schema, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string vhost, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string app, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string stream);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_http_body_from_string", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkHttpBodyFromString([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str, ulong len);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_http_body_from_file", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkHttpBodyFromFile([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string file_path);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_http_body_from_multi_form", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkHttpBodyFromMultiForm([MarshalAs(UnmanagedType.LPArray)] string[] key_val, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string file_path);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_http_body_release", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkHttpBodyRelease(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_http_response_invoker_do", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkHttpResponseInvokerDo(IntPtr ctx, int response_code, sbyte** response_header, IntPtr response_body);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_http_response_invoker_do_string", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkHttpResponseInvokerDoString(IntPtr ctx, int response_code, sbyte** response_header, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string response_content);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_http_response_invoker_do_file", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkHttpResponseInvokerDoFile(IntPtr ctx, IntPtr request_parser, [MarshalAs(UnmanagedType.LPArray)] string[] response_header, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string response_file_path);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_http_response_invoker_clone", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkHttpResponseInvokerClone(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_http_response_invoker_clone_release", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkHttpResponseInvokerCloneRelease(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_http_access_path_invoker_do", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkHttpAccessPathInvokerDo(IntPtr ctx, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string err_msg, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string access_path, int cookie_life_second);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_http_access_path_invoker_clone", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkHttpAccessPathInvokerClone(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_http_access_path_invoker_clone_release", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkHttpAccessPathInvokerCloneRelease(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_rtsp_get_realm_invoker_do", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkRtspGetRealmInvokerDo(IntPtr ctx, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string realm);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_rtsp_get_realm_invoker_clone", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkRtspGetRealmInvokerClone(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_rtsp_get_realm_invoker_clone_release", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkRtspGetRealmInvokerCloneRelease(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_rtsp_auth_invoker_do", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkRtspAuthInvokerDo(IntPtr ctx, int encrypted, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string pwd_or_md5);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_rtsp_auth_invoker_clone", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkRtspAuthInvokerClone(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_rtsp_auth_invoker_clone_release", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkRtspAuthInvokerCloneRelease(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_publish_auth_invoker_do", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkPublishAuthInvokerDo(IntPtr ctx, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string err_msg, int enable_hls, int enable_mp4);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_publish_auth_invoker_clone", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkPublishAuthInvokerClone(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_publish_auth_invoker_clone_release", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkPublishAuthInvokerCloneRelease(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_auth_invoker_do", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkAuthInvokerDo(IntPtr ctx, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string err_msg);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_auth_invoker_clone", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkAuthInvokerClone(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_auth_invoker_clone_release", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkAuthInvokerCloneRelease(IntPtr ctx);
        }

        public static ulong MkMp4InfoGetStartTime(IntPtr ctx)
        {
            var __ret = __Internal.MkMp4InfoGetStartTime(ctx);
            return __ret;
        }

        public static float MkMp4InfoGetTimeLen(IntPtr ctx)
        {
            var __ret = __Internal.MkMp4InfoGetTimeLen(ctx);
            return __ret;
        }

        public static ulong MkMp4InfoGetFileSize(IntPtr ctx)
        {
            var __ret = __Internal.MkMp4InfoGetFileSize(ctx);
            return __ret;
        }

        public static string MkMp4InfoGetFilePath(IntPtr ctx)
        {
            var __ret = __Internal.MkMp4InfoGetFilePath(ctx);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static string MkMp4InfoGetFileName(IntPtr ctx)
        {
            var __ret = __Internal.MkMp4InfoGetFileName(ctx);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static string MkMp4InfoGetFolder(IntPtr ctx)
        {
            var __ret = __Internal.MkMp4InfoGetFolder(ctx);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static string MkMp4InfoGetUrl(IntPtr ctx)
        {
            var __ret = __Internal.MkMp4InfoGetUrl(ctx);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static string MkMp4InfoGetVhost(IntPtr ctx)
        {
            var __ret = __Internal.MkMp4InfoGetVhost(ctx);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static string MkMp4InfoGetApp(IntPtr ctx)
        {
            var __ret = __Internal.MkMp4InfoGetApp(ctx);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static string MkMp4InfoGetStream(IntPtr ctx)
        {
            var __ret = __Internal.MkMp4InfoGetStream(ctx);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static string MkParserGetMethod(IntPtr ctx)
        {
            var __ret = __Internal.MkParserGetMethod(ctx);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static string MkParserGetUrl(IntPtr ctx)
        {
            var __ret = __Internal.MkParserGetUrl(ctx);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static string MkParserGetUrlParams(IntPtr ctx)
        {
            var __ret = __Internal.MkParserGetUrlParams(ctx);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static string MkParserGetUrlParam(IntPtr ctx, string key)
        {
            var __ret = __Internal.MkParserGetUrlParam(ctx, key);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static string MkParserGetTail(IntPtr ctx)
        {
            var __ret = __Internal.MkParserGetTail(ctx);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static string MkParserGetHeader(IntPtr ctx, string key)
        {
            var __ret = __Internal.MkParserGetHeader(ctx, key);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static string MkParserGetContent(IntPtr ctx, ref ulong length)
        {
            fixed (ulong* __length1 = &length)
            {
                var __arg1 = __length1;
                var __ret = __Internal.MkParserGetContent(ctx, __arg1);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
            }
        }

        public static string MkMediaInfoGetParams(IntPtr ctx)
        {
            var __ret = __Internal.MkMediaInfoGetParams(ctx);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static string MkMediaInfoGetSchema(IntPtr ctx)
        {
            var __ret = __Internal.MkMediaInfoGetSchema(ctx);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static string MkMediaInfoGetVhost(IntPtr ctx)
        {
            var __ret = __Internal.MkMediaInfoGetVhost(ctx);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static string MkMediaInfoGetApp(IntPtr ctx)
        {
            var __ret = __Internal.MkMediaInfoGetApp(ctx);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static string MkMediaInfoGetStream(IntPtr ctx)
        {
            var __ret = __Internal.MkMediaInfoGetStream(ctx);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static string MkMediaInfoGetHost(IntPtr ctx)
        {
            var __ret = __Internal.MkMediaInfoGetHost(ctx);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static ushort MkMediaInfoGetPort(IntPtr ctx)
        {
            var __ret = __Internal.MkMediaInfoGetPort(ctx);
            return __ret;
        }

        public static string MkMediaSourceGetSchema(IntPtr ctx)
        {
            var __ret = __Internal.MkMediaSourceGetSchema(ctx);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static string MkMediaSourceGetVhost(IntPtr ctx)
        {
            var __ret = __Internal.MkMediaSourceGetVhost(ctx);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static string MkMediaSourceGetApp(IntPtr ctx)
        {
            var __ret = __Internal.MkMediaSourceGetApp(ctx);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static string MkMediaSourceGetStream(IntPtr ctx)
        {
            var __ret = __Internal.MkMediaSourceGetStream(ctx);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static int MkMediaSourceGetReaderCount(IntPtr ctx)
        {
            var __ret = __Internal.MkMediaSourceGetReaderCount(ctx);
            return __ret;
        }

        public static int MkMediaSourceGetTotalReaderCount(IntPtr ctx)
        {
            var __ret = __Internal.MkMediaSourceGetTotalReaderCount(ctx);
            return __ret;
        }

        /// <summary>
        /// <para>直播源在ZLMediaKit中被称作为MediaSource，</para>
        /// <para>目前支持3种，分别是RtmpMediaSource、RtspMediaSource、HlsMediaSource</para>
        /// <para>源的产生有被动和主动方式:</para>
        /// <para>被动方式分别是rtsp/rtmp/rtp推流、mp4点播</para>
        /// <para>主动方式包括mk_media_create创建的对象(DevChannel)、mk_proxy_player_create创建的对象(PlayerProxy)</para>
        /// <para>被动方式你不用做任何处理，ZLMediaKit已经默认适配了MediaSource::close()事件，都会关闭直播流</para>
        /// <para>主动方式你要设置这个事件的回调，你要自己选择删除对象</para>
        /// <para>通过mk_proxy_player_set_on_close、mk_media_set_on_close函数可以设置回调,</para>
        /// <para>请在回调中删除对象来完成媒体的关闭，否则又为什么要调用mk_media_source_close函数？</para>
        /// </summary>
        /// <param name="ctx">对象</param>
        /// <param name="force">是否强制关闭，如果强制关闭，在有人观看的情况下也会关闭</param>
        /// <returns>0代表失败，1代表成功</returns>
        public static int MkMediaSourceClose(IntPtr ctx, int force)
        {
            var __ret = __Internal.MkMediaSourceClose(ctx, force);
            return __ret;
        }

        public static int MkMediaSourceSeekTo(IntPtr ctx, uint stamp)
        {
            var __ret = __Internal.MkMediaSourceSeekTo(ctx, stamp);
            return __ret;
        }

        public static void MkMediaSourceStartSendRtp(IntPtr ctx, string dst_url, ushort dst_port, string ssrc, int is_udp, global::ZLMediaKit.OnMkMediaSourceSendRtpResult cb, IntPtr user_data)
        {
            var __arg5 = cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cb);
            __Internal.MkMediaSourceStartSendRtp(ctx, dst_url, dst_port, ssrc, is_udp, __arg5, user_data);
        }

        public static int MkMediaSourceStopSendRtp(IntPtr ctx)
        {
            var __ret = __Internal.MkMediaSourceStopSendRtp(ctx);
            return __ret;
        }

        public static void MkMediaSourceFind(string schema, string vhost, string app, string stream, int from_mp4, IntPtr user_data, global::ZLMediaKit.OnMkMediaSourceFindCb cb)
        {
            var __arg6 = cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cb);
            __Internal.MkMediaSourceFind(schema, vhost, app, stream, from_mp4, user_data, __arg6);
        }

        public static void MkMediaSourceForEach(IntPtr user_data, global::ZLMediaKit.OnMkMediaSourceFindCb cb, string schema, string vhost, string app, string stream)
        {
            var __arg1 = cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cb);
            __Internal.MkMediaSourceForEach(user_data, __arg1, schema, vhost, app, stream);
        }

        /// <summary>生成HttpStringBody</summary>
        /// <param name="str">字符串指针</param>
        /// <param name="len">字符串长度，为0则用strlen获取</param>
        public static IntPtr MkHttpBodyFromString(string str, ulong len)
        {
            var __ret = __Internal.MkHttpBodyFromString(str, len);
            return __ret;
        }

        /// <summary>生成HttpFileBody</summary>
        /// <param name="file_path">文件完整路径</param>
        public static IntPtr MkHttpBodyFromFile(string file_path)
        {
            var __ret = __Internal.MkHttpBodyFromFile(file_path);
            return __ret;
        }

        /// <summary>生成HttpMultiFormBody</summary>
        /// <param name="key_val">参数key-value</param>
        /// <param name="file_path">文件完整路径</param>
        public static IntPtr MkHttpBodyFromMultiForm(string[] key_val, string file_path)
        {
            var __ret = __Internal.MkHttpBodyFromMultiForm(key_val, file_path);
            return __ret;
        }

        /// <summary>销毁HttpBody</summary>
        public static void MkHttpBodyRelease(IntPtr ctx)
        {
            __Internal.MkHttpBodyRelease(ctx);
        }

        /// <summary>HttpSession::HttpResponseInvoker(const string&amp;codeOut, const StrCaseMap&amp;headerOut, const HttpBody::Ptr&amp;body);</summary>
        /// <param name="response_code">譬如200</param>
        /// <param name="response_header">返回的http头，譬如 {&quot;Content-Type&quot;,&quot;text/html&quot;,NULL} 必须以NULL结尾</param>
        /// <param name="response_body">body对象</param>
        public static void MkHttpResponseInvokerDo(IntPtr ctx, int response_code, sbyte** response_header, IntPtr response_body)
        {
            __Internal.MkHttpResponseInvokerDo(ctx, response_code, response_header, response_body);
        }

        /// <summary>HttpSession::HttpResponseInvoker(const string&amp;codeOut, const StrCaseMap&amp;headerOut, const string&amp;body);</summary>
        /// <param name="response_code">譬如200</param>
        /// <param name="response_header">返回的http头，譬如 {&quot;Content-Type&quot;,&quot;text/html&quot;,NULL} 必须以NULL结尾</param>
        /// <param name="response_content">返回的content部分，譬如一个网页内容</param>
        public static void MkHttpResponseInvokerDoString(IntPtr ctx, int response_code, sbyte** response_header, string response_content)
        {
            __Internal.MkHttpResponseInvokerDoString(ctx, response_code, response_header, response_content);
        }

        /// <summary>HttpSession::HttpResponseInvoker(const StrCaseMap&amp;requestHeader,const StrCaseMap&amp;responseHeader,const string&amp;filePath);</summary>
        /// <param name="request_parser">请求事件中的mk_parser对象，用于提取其中http头中的Range字段，通过该字段先fseek然后再发送文件部分片段</param>
        /// <param name="response_header">返回的http头，譬如 {&quot;Content-Type&quot;,&quot;text/html&quot;,NULL} 必须以NULL结尾</param>
        /// <param name="response_file_path">返回的content部分，譬如/path/to/html/file</param>
        public static void MkHttpResponseInvokerDoFile(IntPtr ctx, IntPtr request_parser, string[] response_header, string response_file_path)
        {
            __Internal.MkHttpResponseInvokerDoFile(ctx, request_parser, response_header, response_file_path);
        }

        /// <summary>
        /// <para>克隆mk_http_response_invoker对象，通过克隆对象为堆对象，可以实现跨线程异步执行mk_http_response_invoker_do</para>
        /// <para>如果是同步执行mk_http_response_invoker_do，那么没必要克隆对象</para>
        /// </summary>
        public static IntPtr MkHttpResponseInvokerClone(IntPtr ctx)
        {
            var __ret = __Internal.MkHttpResponseInvokerClone(ctx);
            return __ret;
        }

        /// <summary>销毁堆上的克隆对象</summary>
        public static void MkHttpResponseInvokerCloneRelease(IntPtr ctx)
        {
            __Internal.MkHttpResponseInvokerCloneRelease(ctx);
        }

        /// <summary>HttpSession::HttpAccessPathInvoker(const string&amp;errMsg,const string&amp;accessPath, int cookieLifeSecond);</summary>
        /// <param name="err_msg">如果为空，则代表鉴权通过，否则为错误提示,可以为null</param>
        /// <param name="access_path">运行或禁止访问的根目录,可以为null</param>
        /// <param name="cookie_life_second">鉴权cookie有效期</param>
        public static void MkHttpAccessPathInvokerDo(IntPtr ctx, string err_msg, string access_path, int cookie_life_second)
        {
            __Internal.MkHttpAccessPathInvokerDo(ctx, err_msg, access_path, cookie_life_second);
        }

        /// <summary>
        /// <para>克隆mk_http_access_path_invoker对象，通过克隆对象为堆对象，可以实现跨线程异步执行mk_http_access_path_invoker_do</para>
        /// <para>如果是同步执行mk_http_access_path_invoker_do，那么没必要克隆对象</para>
        /// </summary>
        public static IntPtr MkHttpAccessPathInvokerClone(IntPtr ctx)
        {
            var __ret = __Internal.MkHttpAccessPathInvokerClone(ctx);
            return __ret;
        }

        /// <summary>销毁堆上的克隆对象</summary>
        public static void MkHttpAccessPathInvokerCloneRelease(IntPtr ctx)
        {
            __Internal.MkHttpAccessPathInvokerCloneRelease(ctx);
        }

        /// <summary>执行RtspSession::onGetRealm</summary>
        /// <param name="realm">该rtsp流是否需要开启rtsp专属鉴权，至null或空字符串则不鉴权</param>
        public static void MkRtspGetRealmInvokerDo(IntPtr ctx, string realm)
        {
            __Internal.MkRtspGetRealmInvokerDo(ctx, realm);
        }

        /// <summary>
        /// <para>克隆mk_rtsp_get_realm_invoker对象，通过克隆对象为堆对象，可以实现跨线程异步执行mk_rtsp_get_realm_invoker_do</para>
        /// <para>如果是同步执行mk_rtsp_get_realm_invoker_do，那么没必要克隆对象</para>
        /// </summary>
        public static IntPtr MkRtspGetRealmInvokerClone(IntPtr ctx)
        {
            var __ret = __Internal.MkRtspGetRealmInvokerClone(ctx);
            return __ret;
        }

        /// <summary>销毁堆上的克隆对象</summary>
        public static void MkRtspGetRealmInvokerCloneRelease(IntPtr ctx)
        {
            __Internal.MkRtspGetRealmInvokerCloneRelease(ctx);
        }

        /// <summary>执行RtspSession::onAuth</summary>
        /// <param name="encrypted">为true是则表明是md5加密的密码，否则是明文密码, 在请求明文密码时如果提供md5密码者则会导致认证失败</param>
        /// <param name="pwd_or_md5">明文密码或者md5加密的密码</param>
        public static void MkRtspAuthInvokerDo(IntPtr ctx, int encrypted, string pwd_or_md5)
        {
            __Internal.MkRtspAuthInvokerDo(ctx, encrypted, pwd_or_md5);
        }

        /// <summary>
        /// <para>克隆mk_rtsp_auth_invoker对象，通过克隆对象为堆对象，可以实现跨线程异步执行mk_rtsp_auth_invoker_do</para>
        /// <para>如果是同步执行mk_rtsp_auth_invoker_do，那么没必要克隆对象</para>
        /// </summary>
        public static IntPtr MkRtspAuthInvokerClone(IntPtr ctx)
        {
            var __ret = __Internal.MkRtspAuthInvokerClone(ctx);
            return __ret;
        }

        /// <summary>销毁堆上的克隆对象</summary>
        public static void MkRtspAuthInvokerCloneRelease(IntPtr ctx)
        {
            __Internal.MkRtspAuthInvokerCloneRelease(ctx);
        }

        /// <summary>执行Broadcast::PublishAuthInvoker</summary>
        /// <param name="err_msg">为空或null则代表鉴权成功</param>
        /// <param name="enable_hls">是否允许转换hls</param>
        /// <param name="enable_mp4">是否运行MP4录制</param>
        public static void MkPublishAuthInvokerDo(IntPtr ctx, string err_msg, int enable_hls, int enable_mp4)
        {
            __Internal.MkPublishAuthInvokerDo(ctx, err_msg, enable_hls, enable_mp4);
        }

        /// <summary>
        /// <para>克隆mk_publish_auth_invoker对象，通过克隆对象为堆对象，可以实现跨线程异步执行mk_publish_auth_invoker_do</para>
        /// <para>如果是同步执行mk_publish_auth_invoker_do，那么没必要克隆对象</para>
        /// </summary>
        public static IntPtr MkPublishAuthInvokerClone(IntPtr ctx)
        {
            var __ret = __Internal.MkPublishAuthInvokerClone(ctx);
            return __ret;
        }

        /// <summary>销毁堆上的克隆对象</summary>
        public static void MkPublishAuthInvokerCloneRelease(IntPtr ctx)
        {
            __Internal.MkPublishAuthInvokerCloneRelease(ctx);
        }

        /// <summary>执行Broadcast::AuthInvoker</summary>
        /// <param name="err_msg">为空或null则代表鉴权成功</param>
        public static void MkAuthInvokerDo(IntPtr ctx, string err_msg)
        {
            __Internal.MkAuthInvokerDo(ctx, err_msg);
        }

        /// <summary>
        /// <para>克隆mk_auth_invoker对象，通过克隆对象为堆对象，可以实现跨线程异步执行mk_auth_invoker_do</para>
        /// <para>如果是同步执行mk_auth_invoker_do，那么没必要克隆对象</para>
        /// </summary>
        public static IntPtr MkAuthInvokerClone(IntPtr ctx)
        {
            var __ret = __Internal.MkAuthInvokerClone(ctx);
            return __ret;
        }

        /// <summary>销毁堆上的克隆对象</summary>
        public static void MkAuthInvokerCloneRelease(IntPtr ctx)
        {
            __Internal.MkAuthInvokerCloneRelease(ctx);
        }
    }

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void OnMkFrameDataRelease(IntPtr user_data, sbyte* ptr);

    public unsafe partial class mk_frame
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_frame_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkFrameCreate(int codec_id, ulong dts, ulong pts, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string data, ulong size, IntPtr cb, IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_frame_unref", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkFrameUnref(IntPtr frame);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_frame_ref", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkFrameRef(IntPtr frame);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_frame_codec_id", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int MkFrameCodecId(IntPtr frame);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_frame_codec_name", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkFrameCodecName(IntPtr frame);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_frame_is_video", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int MkFrameIsVideo(IntPtr frame);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_frame_get_data", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkFrameGetData(IntPtr frame);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_frame_get_data_size", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ulong MkFrameGetDataSize(IntPtr frame);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_frame_get_data_prefix_size", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ulong MkFrameGetDataPrefixSize(IntPtr frame);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_frame_get_dts", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ulong MkFrameGetDts(IntPtr frame);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_frame_get_pts", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ulong MkFrameGetPts(IntPtr frame);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_frame_get_flags", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint MkFrameGetFlags(IntPtr frame);
        }

        /// <summary>创建frame对象，并返回其引用</summary>
        /// <param name="codec_id">编解码类型，请参考MKCodecXXX定义</param>
        /// <param name="dts">解码时间戳，单位毫秒</param>
        /// <param name="pts">显示时间戳，单位毫秒</param>
        /// <param name="data">单帧数据</param>
        /// <param name="size">单帧数据长度</param>
        /// <param name="cb">data指针free释放回调, 如果为空，内部会拷贝数据</param>
        /// <param name="user_data">data指针free释放回调用户指针</param>
        /// <returns>frame对象引用</returns>
        public static IntPtr MkFrameCreate(int codec_id, ulong dts, ulong pts, string data, ulong size, global::ZLMediaKit.OnMkFrameDataRelease cb, IntPtr user_data)
        {
            var __arg5 = cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cb);
            var __ret = __Internal.MkFrameCreate(codec_id, dts, pts, data, size, __arg5, user_data);
            return __ret;
        }

        /// <summary>减引用frame对象</summary>
        /// <param name="frame">帧对象引用</param>
        public static void MkFrameUnref(IntPtr frame)
        {
            __Internal.MkFrameUnref(frame);
        }

        /// <summary>引用frame对象</summary>
        /// <param name="frame">被引用的frame对象</param>
        /// <returns>新的对象引用</returns>
        public static IntPtr MkFrameRef(IntPtr frame)
        {
            var __ret = __Internal.MkFrameRef(frame);
            return __ret;
        }

        /// <summary>获取frame 编码codec类型，请参考MKCodecXXX定义</summary>
        public static int MkFrameCodecId(IntPtr frame)
        {
            var __ret = __Internal.MkFrameCodecId(frame);
            return __ret;
        }

        /// <summary>获取帧编码codec名称</summary>
        public static string MkFrameCodecName(IntPtr frame)
        {
            var __ret = __Internal.MkFrameCodecName(frame);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        /// <summary>帧是否为视频</summary>
        public static int MkFrameIsVideo(IntPtr frame)
        {
            var __ret = __Internal.MkFrameIsVideo(frame);
            return __ret;
        }

        /// <summary>获取帧数据指针</summary>
        public static string MkFrameGetData(IntPtr frame)
        {
            var __ret = __Internal.MkFrameGetData(frame);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        /// <summary>获取帧数据指针长度</summary>
        public static ulong MkFrameGetDataSize(IntPtr frame)
        {
            var __ret = __Internal.MkFrameGetDataSize(frame);
            return __ret;
        }

        /// <summary>返回帧数据前缀长度，譬如H264/H265前缀一般是0x00 00 00 01,那么本函数返回4</summary>
        public static ulong MkFrameGetDataPrefixSize(IntPtr frame)
        {
            var __ret = __Internal.MkFrameGetDataPrefixSize(frame);
            return __ret;
        }

        /// <summary>获取解码时间戳，单位毫秒</summary>
        public static ulong MkFrameGetDts(IntPtr frame)
        {
            var __ret = __Internal.MkFrameGetDts(frame);
            return __ret;
        }

        /// <summary>获取显示时间戳，单位毫秒</summary>
        public static ulong MkFrameGetPts(IntPtr frame)
        {
            var __ret = __Internal.MkFrameGetPts(frame);
            return __ret;
        }

        /// <summary>获取帧flag，请参考 MK_FRAME_FLAG</summary>
        public static uint MkFrameGetFlags(IntPtr frame)
        {
            var __ret = __Internal.MkFrameGetFlags(frame);
            return __ret;
        }

        public static int MKCodecH264
        {
            get
            {
                var __ptr = (int*)global::ZLMediaKit.__Symbols.mk_api._MKCodecH264;
                return *__ptr;
            }
        }

        public static int MKCodecH265
        {
            get
            {
                var __ptr = (int*)global::ZLMediaKit.__Symbols.mk_api._MKCodecH265;
                return *__ptr;
            }
        }

        public static int MKCodecAAC
        {
            get
            {
                var __ptr = (int*)global::ZLMediaKit.__Symbols.mk_api._MKCodecAAC;
                return *__ptr;
            }
        }

        public static int MKCodecG711A
        {
            get
            {
                var __ptr = (int*)global::ZLMediaKit.__Symbols.mk_api._MKCodecG711A;
                return *__ptr;
            }
        }

        public static int MKCodecG711U
        {
            get
            {
                var __ptr = (int*)global::ZLMediaKit.__Symbols.mk_api._MKCodecG711U;
                return *__ptr;
            }
        }

        public static int MKCodecOpus
        {
            get
            {
                var __ptr = (int*)global::ZLMediaKit.__Symbols.mk_api._MKCodecOpus;
                return *__ptr;
            }
        }

        public static int MKCodecL16
        {
            get
            {
                var __ptr = (int*)global::ZLMediaKit.__Symbols.mk_api._MKCodecL16;
                return *__ptr;
            }
        }

        public static int MKCodecVP8
        {
            get
            {
                var __ptr = (int*)global::ZLMediaKit.__Symbols.mk_api._MKCodecVP8;
                return *__ptr;
            }
        }

        public static int MKCodecVP9
        {
            get
            {
                var __ptr = (int*)global::ZLMediaKit.__Symbols.mk_api._MKCodecVP9;
                return *__ptr;
            }
        }

        public static int MKCodecAV1
        {
            get
            {
                var __ptr = (int*)global::ZLMediaKit.__Symbols.mk_api._MKCodecAV1;
                return *__ptr;
            }
        }

        public static int MKCodecJPEG
        {
            get
            {
                var __ptr = (int*)global::ZLMediaKit.__Symbols.mk_api._MKCodecJPEG;
                return *__ptr;
            }
        }
    }

    /// <summary>h264 分帧器输出回调函数</summary>
    /// <param name="user_data">设置回调时的用户数据指针</param>
    /// <param name="splitter">对象</param>
    /// <param name="frame">帧数据</param>
    /// <param name="size">帧数据长度</param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void OnMkH264SplitterFrame(IntPtr user_data, IntPtr splitter, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string frame, int size);

    public unsafe partial class mk_h264_splitter
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_h264_splitter_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkH264SplitterCreate(IntPtr cb, IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_h264_splitter_release", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkH264SplitterRelease(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_h264_splitter_input_data", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkH264SplitterInputData(IntPtr ctx, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string data, int size);
        }

        /// <summary>创建h264分帧器</summary>
        /// <param name="cb">分帧回调函数</param>
        /// <param name="user_data">回调用户数据指针</param>
        /// <returns>分帧器对象</returns>
        public static IntPtr MkH264SplitterCreate(global::ZLMediaKit.OnMkH264SplitterFrame cb, IntPtr user_data)
        {
            var __arg0 = cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cb);
            var __ret = __Internal.MkH264SplitterCreate(__arg0, user_data);
            return __ret;
        }

        /// <summary>删除h264分帧器</summary>
        /// <param name="ctx">分帧器</param>
        public static void MkH264SplitterRelease(IntPtr ctx)
        {
            __Internal.MkH264SplitterRelease(ctx);
        }

        /// <summary>输入数据并分帧</summary>
        /// <param name="ctx">分帧器</param>
        /// <param name="data">h264/h265数据</param>
        /// <param name="size">数据长度</param>
        public static void MkH264SplitterInputData(IntPtr ctx, string data, int size)
        {
            __Internal.MkH264SplitterInputData(ctx, data, size);
        }
    }

    /// <summary>////////////////////////////////////////HttpDownloader/////////////////////////////////////////////</summary>
    /// <param name="user_data">用户数据指针</param>
    /// <param name="code">错误代码，0代表成功</param>
    /// <param name="err_msg">错误提示</param>
    /// <param name="file_path">文件保存路径</param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void OnMkDownloadComplete(IntPtr user_data, int code, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string err_msg, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string file_path);

    /// <summary>////////////////////////////////////////HttpRequester/////////////////////////////////////////////</summary>
    /// <summary>
    /// <para>http请求结果回调</para>
    /// <para>在code == 0时代表本次http会话是完整的（收到了http回复）</para>
    /// <para>用户应该通过user_data获取到mk_http_requester对象</para>
    /// <para>然后通过mk_http_requester_get_response等函数获取相关回复数据</para>
    /// <para>在回调结束时，应该通过mk_http_requester_release函数销毁该对象</para>
    /// <para>或者调用mk_http_requester_clear函数后再复用该对象</para>
    /// </summary>
    /// <param name="user_data">用户数据指针</param>
    /// <param name="code">错误代码，0代表成功</param>
    /// <param name="err_msg">错误提示</param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void OnMkHttpRequesterComplete(IntPtr user_data, int code, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string err_msg);

    public unsafe partial class mk_httpclient
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_http_downloader_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkHttpDownloaderCreate();

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_http_downloader_release", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkHttpDownloaderRelease(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_http_downloader_start", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkHttpDownloaderStart(IntPtr ctx, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string url, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string file, IntPtr cb, IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_http_requester_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkHttpRequesterCreate();

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_http_requester_clear", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkHttpRequesterClear(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_http_requester_release", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkHttpRequesterRelease(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_http_requester_set_method", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkHttpRequesterSetMethod(IntPtr ctx, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string method);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_http_requester_set_header", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkHttpRequesterSetHeader(IntPtr ctx, [MarshalAs(UnmanagedType.LPArray)] string[] header);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_http_requester_add_header", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkHttpRequesterAddHeader(IntPtr ctx, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string key, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string value, int force);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_http_requester_set_body", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkHttpRequesterSetBody(IntPtr ctx, IntPtr body);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_http_requester_get_response_status", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkHttpRequesterGetResponseStatus(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_http_requester_get_response_header", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkHttpRequesterGetResponseHeader(IntPtr ctx, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string key);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_http_requester_get_response_body", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkHttpRequesterGetResponseBody(IntPtr ctx, ulong* length);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_http_requester_get_response", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkHttpRequesterGetResponse(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_http_requester_set_cb", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkHttpRequesterSetCb(IntPtr ctx, IntPtr cb, IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_http_requester_start", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkHttpRequesterStart(IntPtr ctx, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string url, float timeout_second);
        }

        /// <summary>创建http[s]下载器</summary>
        /// <returns>下载器指针</returns>
        public static IntPtr MkHttpDownloaderCreate()
        {
            var __ret = __Internal.MkHttpDownloaderCreate();
            return __ret;
        }

        /// <summary>销毁http[s]下载器</summary>
        /// <param name="ctx">下载器指针</param>
        public static void MkHttpDownloaderRelease(IntPtr ctx)
        {
            __Internal.MkHttpDownloaderRelease(ctx);
        }

        /// <summary>开始http[s]下载</summary>
        /// <param name="ctx">下载器指针</param>
        /// <param name="url">http[s]下载url</param>
        /// <param name="file">文件保存路径</param>
        /// <param name="cb">回调函数</param>
        /// <param name="user_data">用户数据指针</param>
        public static void MkHttpDownloaderStart(IntPtr ctx, string url, string file, global::ZLMediaKit.OnMkDownloadComplete cb, IntPtr user_data)
        {
            var __arg3 = cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cb);
            __Internal.MkHttpDownloaderStart(ctx, url, file, __arg3, user_data);
        }

        /// <summary>创建HttpRequester</summary>
        public static IntPtr MkHttpRequesterCreate()
        {
            var __ret = __Internal.MkHttpRequesterCreate();
            return __ret;
        }

        /// <summary>在复用mk_http_requester对象时才需要用到此方法</summary>
        public static void MkHttpRequesterClear(IntPtr ctx)
        {
            __Internal.MkHttpRequesterClear(ctx);
        }

        /// <summary>
        /// <para>销毁HttpRequester</para>
        /// <para>如果调用了mk_http_requester_start函数且正在等待http回复，</para>
        /// <para>也可以调用mk_http_requester_release方法取消本次http请求</para>
        /// </summary>
        public static void MkHttpRequesterRelease(IntPtr ctx)
        {
            __Internal.MkHttpRequesterRelease(ctx);
        }

        /// <summary>设置HTTP方法，譬如GET/POST</summary>
        public static void MkHttpRequesterSetMethod(IntPtr ctx, string method)
        {
            __Internal.MkHttpRequesterSetMethod(ctx, method);
        }

        /// <summary>批量设置设置HTTP头</summary>
        /// <param name="header">譬如 {&quot;Content-Type&quot;,&quot;text/html&quot;,NULL} 必须以NULL结尾</param>
        public static void MkHttpRequesterSetHeader(IntPtr ctx, string[] header)
        {
            __Internal.MkHttpRequesterSetHeader(ctx, header);
        }

        /// <summary>添加HTTP头</summary>
        /// <param name="key">譬如Content-Type</param>
        /// <param name="value">譬如 text/html</param>
        /// <param name="force">如果已经存在该key，是否强制替换</param>
        public static void MkHttpRequesterAddHeader(IntPtr ctx, string key, string value, int force)
        {
            __Internal.MkHttpRequesterAddHeader(ctx, key, value, force);
        }

        /// <summary>设置消息体，</summary>
        /// <param name="body">mk_http_body对象，通过mk_http_body_from_string等函数生成，使用完毕后请调用mk_http_body_release释放之</param>
        public static void MkHttpRequesterSetBody(IntPtr ctx, IntPtr body)
        {
            __Internal.MkHttpRequesterSetBody(ctx, body);
        }

        /// <summary>在收到HTTP回复后可调用该方法获取状态码</summary>
        /// <returns>譬如 200 OK</returns>
        public static string MkHttpRequesterGetResponseStatus(IntPtr ctx)
        {
            var __ret = __Internal.MkHttpRequesterGetResponseStatus(ctx);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        /// <summary>在收到HTTP回复后可调用该方法获取响应HTTP头</summary>
        /// <param name="key">HTTP头键名</param>
        /// <returns>HTTP头键值</returns>
        public static string MkHttpRequesterGetResponseHeader(IntPtr ctx, string key)
        {
            var __ret = __Internal.MkHttpRequesterGetResponseHeader(ctx, key);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        /// <summary>在收到HTTP回复后可调用该方法获取响应HTTP body</summary>
        /// <param name="length">返回body长度,可以为null</param>
        /// <returns>body指针</returns>
        public static string MkHttpRequesterGetResponseBody(IntPtr ctx, ref ulong length)
        {
            fixed (ulong* __length1 = &length)
            {
                var __arg1 = __length1;
                var __ret = __Internal.MkHttpRequesterGetResponseBody(ctx, __arg1);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
            }
        }

        /// <summary>在收到HTTP回复后可调用该方法获取响应</summary>
        /// <returns>响应对象</returns>
        public static IntPtr MkHttpRequesterGetResponse(IntPtr ctx)
        {
            var __ret = __Internal.MkHttpRequesterGetResponse(ctx);
            return __ret;
        }

        /// <summary>设置回调函数</summary>
        /// <param name="cb">回调函数，不能为空</param>
        /// <param name="user_data">用户数据指针</param>
        public static void MkHttpRequesterSetCb(IntPtr ctx, global::ZLMediaKit.OnMkHttpRequesterComplete cb, IntPtr user_data)
        {
            var __arg1 = cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cb);
            __Internal.MkHttpRequesterSetCb(ctx, __arg1, user_data);
        }

        /// <summary>开始url请求</summary>
        /// <param name="url">请求url，支持http/https</param>
        /// <param name="timeout_second">最大超时时间</param>
        public static void MkHttpRequesterStart(IntPtr ctx, string url, float timeout_second)
        {
            __Internal.MkHttpRequesterStart(ctx, url, timeout_second);
        }
    }

    /// <summary>
    /// <para>MediaSource.close()回调事件</para>
    /// <para>在选择关闭一个关联的MediaSource时，将会最终触发到该回调</para>
    /// <para>你应该通过该事件调用mk_media_release函数并且释放其他资源</para>
    /// <para>如果你不调用mk_media_release函数，那么MediaSource.close()操作将无效</para>
    /// </summary>
    /// <param name="user_data">用户数据指针，通过mk_media_set_on_close函数设置</param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void OnMkMediaClose(IntPtr user_data);

    /// <summary>收到客户端的seek请求时触发该回调</summary>
    /// <param name="user_data">用户数据指针,通过mk_media_set_on_seek设置</param>
    /// <param name="stamp_ms">seek至的时间轴位置，单位毫秒</param>
    /// <returns>1代表将处理seek请求，0代表忽略该请求</returns>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate int OnMkMediaSeek(IntPtr user_data, uint stamp_ms);

    /// <summary>收到客户端的pause或resume请求时触发该回调</summary>
    /// <param name="user_data">用户数据指针,通过mk_media_set_on_pause设置</param>
    /// <param name="pause">1:暂停, 0: 恢复</param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate int OnMkMediaPause(IntPtr user_data, int pause);

    /// <summary>收到客户端的speed请求时触发该回调</summary>
    /// <param name="user_data">用户数据指针,通过mk_media_set_on_pause设置</param>
    /// <param name="speed">0.5 1.0 2.0</param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate int OnMkMediaSpeed(IntPtr user_data, float speed);

    /// <summary>生成的MediaSource注册或注销事件</summary>
    /// <param name="user_data">设置回调时的用户数据指针</param>
    /// <param name="sender">生成的MediaSource对象</param>
    /// <param name="regist">1为注册事件，0为注销事件</param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void OnMkMediaSourceRegist(IntPtr user_data, IntPtr sender, int regist);

    /// <summary>rtp推流成功与否的回调(第一次成功后，后面将一直重试)</summary>
    public unsafe partial class mk_media
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_media_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkMediaCreate([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string vhost, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string app, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string stream, float duration, int hls_enabled, int mp4_enabled);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_media_release", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkMediaRelease(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_media_init_track", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkMediaInitTrack(IntPtr ctx, IntPtr track);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_media_init_video", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int MkMediaInitVideo(IntPtr ctx, int codec_id, int width, int height, float fps, int bit_rate);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_media_init_audio", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int MkMediaInitAudio(IntPtr ctx, int codec_id, int sample_rate, int channels, int sample_bit);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_media_init_complete", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkMediaInitComplete(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_media_input_frame", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int MkMediaInputFrame(IntPtr ctx, IntPtr frame);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_media_input_h264", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int MkMediaInputH264(IntPtr ctx, IntPtr data, int len, ulong dts, ulong pts);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_media_input_h265", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int MkMediaInputH265(IntPtr ctx, IntPtr data, int len, ulong dts, ulong pts);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_media_input_yuv", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkMediaInputYuv(IntPtr ctx, [MarshalAs(UnmanagedType.LPArray)] string[] yuv, int[] linesize, ulong cts);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_media_input_aac", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int MkMediaInputAac(IntPtr ctx, IntPtr data, int len, ulong dts, IntPtr adts);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_media_input_pcm", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int MkMediaInputPcm(IntPtr ctx, IntPtr data, int len, ulong pts);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_media_input_audio", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int MkMediaInputAudio(IntPtr ctx, IntPtr data, int len, ulong dts);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_media_set_on_close", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkMediaSetOnClose(IntPtr ctx, IntPtr cb, IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_media_set_on_seek", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkMediaSetOnSeek(IntPtr ctx, IntPtr cb, IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_media_set_on_pause", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkMediaSetOnPause(IntPtr ctx, IntPtr cb, IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_media_set_on_speed", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkMediaSetOnSpeed(IntPtr ctx, IntPtr cb, IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_media_total_reader_count", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int MkMediaTotalReaderCount(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_media_set_on_regist", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkMediaSetOnRegist(IntPtr ctx, IntPtr cb, IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_media_start_send_rtp", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkMediaStartSendRtp(IntPtr ctx, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string dst_url, ushort dst_port, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string ssrc, int is_udp, IntPtr cb, IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_media_stop_send_rtp", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkMediaStopSendRtp(IntPtr ctx, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string ssrc);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_media_get_owner_thread", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkMediaGetOwnerThread(IntPtr ctx);
        }

        /// <summary>创建一个媒体源</summary>
        /// <param name="vhost">虚拟主机名，一般为__defaultVhost__</param>
        /// <param name="app">应用名，推荐为live</param>
        /// <param name="stream">流id，例如camera</param>
        /// <param name="duration">时长(单位秒)，直播则为0</param>
        /// <param name="hls_enabled">是否生成hls</param>
        /// <param name="mp4_enabled">是否生成mp4</param>
        /// <returns>对象指针</returns>
        public static IntPtr MkMediaCreate(string vhost, string app, string stream, float duration, int hls_enabled, int mp4_enabled)
        {
            var __ret = __Internal.MkMediaCreate(vhost, app, stream, duration, hls_enabled, mp4_enabled);
            return __ret;
        }

        /// <summary>销毁媒体源</summary>
        /// <param name="ctx">对象指针</param>
        public static void MkMediaRelease(IntPtr ctx)
        {
            __Internal.MkMediaRelease(ctx);
        }

        /// <summary>添加音视频track</summary>
        /// <param name="ctx">mk_media对象</param>
        /// <param name="track">mk_track对象，音视频轨道</param>
        public static void MkMediaInitTrack(IntPtr ctx, IntPtr track)
        {
            __Internal.MkMediaInitTrack(ctx, track);
        }

        /// <summary>添加视频轨道，请改用mk_media_init_track方法</summary>
        /// <param name="ctx">对象指针</param>
        /// <param name="codec_id">0:CodecH264/1:CodecH265</param>
        /// <param name="width">视频宽度; 在编码时才有效</param>
        /// <param name="height">视频高度; 在编码时才有效</param>
        /// <param name="fps">视频fps; 在编码时才有效</param>
        /// <param name="bit_rate">视频比特率,单位bps; 在编码时才有效</param>
        /// <param name="width">视频宽度</param>
        /// <param name="height">视频高度</param>
        /// <param name="fps">视频fps</param>
        /// <returns>1代表成功，0失败</returns>
        public static int MkMediaInitVideo(IntPtr ctx, int codec_id, int width, int height, float fps, int bit_rate)
        {
            var __ret = __Internal.MkMediaInitVideo(ctx, codec_id, width, height, fps, bit_rate);
            return __ret;
        }

        /// <summary>添加音频轨道，请改用mk_media_init_track方法</summary>
        /// <param name="ctx">对象指针</param>
        /// <param name="codec_id">2:CodecAAC/3:CodecG711A/4:CodecG711U/5:OPUS</param>
        /// <param name="channel">通道数</param>
        /// <param name="sample_bit">采样位数，只支持16</param>
        /// <param name="sample_rate">采样率</param>
        /// <returns>1代表成功，0失败</returns>
        public static int MkMediaInitAudio(IntPtr ctx, int codec_id, int sample_rate, int channels, int sample_bit)
        {
            var __ret = __Internal.MkMediaInitAudio(ctx, codec_id, sample_rate, channels, sample_bit);
            return __ret;
        }

        /// <summary>
        /// <para>初始化h264/h265/aac完毕后调用此函数，</para>
        /// <para>在单track(只有音频或视频)时，因为ZLMediaKit不知道后续是否还要添加track，所以会多等待3秒钟</para>
        /// <para>如果产生的流是单Track类型，请调用此函数以便加快流生成速度，当然不调用该函数，影响也不大(会多等待3秒)</para>
        /// </summary>
        /// <param name="ctx">对象指针</param>
        public static void MkMediaInitComplete(IntPtr ctx)
        {
            __Internal.MkMediaInitComplete(ctx);
        }

        /// <summary>输入frame对象</summary>
        /// <param name="ctx">mk_media对象</param>
        /// <param name="frame">帧对象</param>
        /// <returns>1代表成功，0失败</returns>
        public static int MkMediaInputFrame(IntPtr ctx, IntPtr frame)
        {
            var __ret = __Internal.MkMediaInputFrame(ctx, frame);
            return __ret;
        }

        /// <summary>输入单帧H264视频，帧起始字节00 00 01,00 00 00 01均可，请改用mk_media_input_frame方法</summary>
        /// <param name="ctx">对象指针</param>
        /// <param name="data">单帧H264数据</param>
        /// <param name="len">单帧H264数据字节数</param>
        /// <param name="dts">解码时间戳，单位毫秒</param>
        /// <param name="pts">播放时间戳，单位毫秒</param>
        /// <returns>1代表成功，0失败</returns>
        public static int MkMediaInputH264(IntPtr ctx, IntPtr data, int len, ulong dts, ulong pts)
        {
            var __ret = __Internal.MkMediaInputH264(ctx, data, len, dts, pts);
            return __ret;
        }

        /// <summary>输入单帧H265视频，帧起始字节00 00 01,00 00 00 01均可，请改用mk_media_input_frame方法</summary>
        /// <param name="ctx">对象指针</param>
        /// <param name="data">单帧H265数据</param>
        /// <param name="len">单帧H265数据字节数</param>
        /// <param name="dts">解码时间戳，单位毫秒</param>
        /// <param name="pts">播放时间戳，单位毫秒</param>
        /// <returns>1代表成功，0失败</returns>
        public static int MkMediaInputH265(IntPtr ctx, IntPtr data, int len, ulong dts, ulong pts)
        {
            var __ret = __Internal.MkMediaInputH265(ctx, data, len, dts, pts);
            return __ret;
        }

        /// <summary>输入YUV视频数据</summary>
        /// <param name="ctx">对象指针</param>
        /// <param name="yuv">yuv420p数据</param>
        /// <param name="linesize">yuv420p linesize</param>
        /// <param name="cts">视频采集时间戳，单位毫秒</param>
        public static void MkMediaInputYuv(IntPtr ctx, string[] yuv, int[] linesize, ulong cts)
        {
            if (yuv == null || yuv.Length != 3)
                throw new ArgumentOutOfRangeException("yuv", "The dimensions of the provided array don't match the required size.");
            if (linesize == null || linesize.Length != 3)
                throw new ArgumentOutOfRangeException("linesize", "The dimensions of the provided array don't match the required size.");
            __Internal.MkMediaInputYuv(ctx, yuv, linesize, cts);
        }

        /// <summary>输入单帧AAC音频(单独指定adts头)，请改用mk_media_input_frame方法</summary>
        /// <param name="ctx">对象指针</param>
        /// <param name="data">不包含adts头的单帧AAC数据，adts头7个字节</param>
        /// <param name="len">单帧AAC数据字节数</param>
        /// <param name="dts">时间戳，毫秒</param>
        /// <param name="adts">adts头，可以为null</param>
        /// <returns>1代表成功，0失败</returns>
        public static int MkMediaInputAac(IntPtr ctx, IntPtr data, int len, ulong dts, IntPtr adts)
        {
            var __ret = __Internal.MkMediaInputAac(ctx, data, len, dts, adts);
            return __ret;
        }

        /// <summary>输入单帧PCM音频,启用ENABLE_FAAC编译时，该函数才有效</summary>
        /// <param name="ctx">对象指针</param>
        /// <param name="data">单帧PCM数据</param>
        /// <param name="len">单帧PCM数据字节数</param>
        /// <param name="dts">时间戳，毫秒</param>
        /// <returns>1代表成功，0失败</returns>
        public static int MkMediaInputPcm(IntPtr ctx, IntPtr data, int len, ulong pts)
        {
            var __ret = __Internal.MkMediaInputPcm(ctx, data, len, pts);
            return __ret;
        }

        /// <summary>输入单帧OPUS/G711音频帧，请改用mk_media_input_frame方法</summary>
        /// <param name="ctx">对象指针</param>
        /// <param name="data">单帧音频数据</param>
        /// <param name="len">单帧音频数据字节数</param>
        /// <param name="dts">时间戳，毫秒</param>
        /// <returns>1代表成功，0失败</returns>
        public static int MkMediaInputAudio(IntPtr ctx, IntPtr data, int len, ulong dts)
        {
            var __ret = __Internal.MkMediaInputAudio(ctx, data, len, dts);
            return __ret;
        }

        /// <summary>
        /// <para>监听MediaSource.close()事件</para>
        /// <para>在选择关闭一个关联的MediaSource时，将会最终触发到该回调</para>
        /// <para>你应该通过该事件调用mk_media_release函数并且释放其他资源</para>
        /// </summary>
        /// <param name="ctx">对象指针</param>
        /// <param name="cb">回调指针</param>
        /// <param name="user_data">用户数据指针</param>
        public static void MkMediaSetOnClose(IntPtr ctx, global::ZLMediaKit.OnMkMediaClose cb, IntPtr user_data)
        {
            var __arg1 = cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cb);
            __Internal.MkMediaSetOnClose(ctx, __arg1, user_data);
        }

        /// <summary>监听播放器seek请求事件</summary>
        /// <param name="ctx">对象指针</param>
        /// <param name="cb">回调指针</param>
        /// <param name="user_data">用户数据指针</param>
        public static void MkMediaSetOnSeek(IntPtr ctx, global::ZLMediaKit.OnMkMediaSeek cb, IntPtr user_data)
        {
            var __arg1 = cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cb);
            __Internal.MkMediaSetOnSeek(ctx, __arg1, user_data);
        }

        /// <summary>监听播放器pause请求事件</summary>
        /// <param name="ctx">对象指针</param>
        /// <param name="cb">回调指针</param>
        /// <param name="user_data">用户数据指针</param>
        public static void MkMediaSetOnPause(IntPtr ctx, global::ZLMediaKit.OnMkMediaPause cb, IntPtr user_data)
        {
            var __arg1 = cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cb);
            __Internal.MkMediaSetOnPause(ctx, __arg1, user_data);
        }

        /// <summary>监听播放器pause请求事件</summary>
        /// <param name="ctx">对象指针</param>
        /// <param name="cb">回调指针</param>
        /// <param name="user_data">用户数据指针</param>
        public static void MkMediaSetOnSpeed(IntPtr ctx, global::ZLMediaKit.OnMkMediaSpeed cb, IntPtr user_data)
        {
            var __arg1 = cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cb);
            __Internal.MkMediaSetOnSpeed(ctx, __arg1, user_data);
        }

        /// <summary>获取总的观看人数</summary>
        /// <param name="ctx">对象指针</param>
        /// <returns>观看人数</returns>
        public static int MkMediaTotalReaderCount(IntPtr ctx)
        {
            var __ret = __Internal.MkMediaTotalReaderCount(ctx);
            return __ret;
        }

        /// <summary>设置MediaSource注册或注销事件回调函数</summary>
        /// <param name="ctx">对象指针</param>
        /// <param name="cb">回调指针</param>
        /// <param name="user_data">用户数据指针</param>
        public static void MkMediaSetOnRegist(IntPtr ctx, global::ZLMediaKit.OnMkMediaSourceRegist cb, IntPtr user_data)
        {
            var __arg1 = cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cb);
            __Internal.MkMediaSetOnRegist(ctx, __arg1, user_data);
        }

        /// <summary>开始发送一路ps-rtp流(通过ssrc区分多路)，此api线程安全</summary>
        /// <param name="ctx">对象指针</param>
        /// <param name="dst_url">目标ip或域名</param>
        /// <param name="dst_port">目标端口</param>
        /// <param name="ssrc">rtp的ssrc，10进制的字符串打印</param>
        /// <param name="is_udp">是否为udp</param>
        /// <param name="cb">启动成功或失败回调</param>
        /// <param name="user_data">回调用户指针</param>
        public static void MkMediaStartSendRtp(IntPtr ctx, string dst_url, ushort dst_port, string ssrc, int is_udp, global::ZLMediaKit.OnMkMediaSourceSendRtpResult cb, IntPtr user_data)
        {
            var __arg5 = cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cb);
            __Internal.MkMediaStartSendRtp(ctx, dst_url, dst_port, ssrc, is_udp, __arg5, user_data);
        }

        /// <summary>停止某路或全部ps-rtp发送，此api线程安全</summary>
        /// <param name="ctx">对象指针</param>
        /// <param name="ssrc">rtp的ssrc，10进制的字符串打印，如果为null或空字符串，则停止所有rtp推流</param>
        public static void MkMediaStopSendRtp(IntPtr ctx, string ssrc)
        {
            __Internal.MkMediaStopSendRtp(ctx, ssrc);
        }

        /// <summary>获取所属线程</summary>
        /// <param name="ctx">对象指针</param>
        public static IntPtr MkMediaGetOwnerThread(IntPtr ctx)
        {
            var __ret = __Internal.MkMediaGetOwnerThread(ctx);
            return __ret;
        }
    }

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void OnMkFrameOut(IntPtr user_data, IntPtr frame);

    public unsafe partial struct CodecArgs
    {
        [StructLayout(LayoutKind.Explicit, Size = 12)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::ZLMediaKit.CodecArgs.Video.__Internal video;

            [FieldOffset(0)]
            internal global::ZLMediaKit.CodecArgs.Audio.__Internal audio;

            [SuppressUnmanagedCodeSecurity, DllImport("ZLMediaKit", EntryPoint = "??0codec_args@@QEAA@AEBT0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr cctor(IntPtr __instance, IntPtr __0);
        }

        public unsafe partial class Video : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 12)]
            public partial struct __Internal
            {
                internal int width;
                internal int height;
                internal int fps;

                [SuppressUnmanagedCodeSecurity, DllImport("ZLMediaKit", EntryPoint = "??0<unnamed-type-video>@codec_args@@QEAA@AEBU01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern IntPtr cctor(IntPtr __instance, IntPtr __0);
            }

            public IntPtr __Instance { get; protected set; }

            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ZLMediaKit.CodecArgs.Video> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ZLMediaKit.CodecArgs.Video>();

            protected bool __ownsNativeInstance;

            internal static Video __CreateInstance(IntPtr native, bool skipVTables = false)
            {
                return new Video(native.ToPointer(), skipVTables);
            }

            internal static Video __GetOrCreateInstance(IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == IntPtr.Zero)
                    return null;
                if (NativeToManagedMap.TryGetValue(native, out var managed))
                    return (Video)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    NativeToManagedMap[native] = result;
                return result;
            }

            internal static Video __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Video(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*)ret = native;
                return ret.ToPointer();
            }

            private Video(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected Video(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new IntPtr(native);
            }

            public Video()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::ZLMediaKit.CodecArgs.Video.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public Video(global::ZLMediaKit.CodecArgs.Video __0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::ZLMediaKit.CodecArgs.Video.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::ZLMediaKit.CodecArgs.Video.__Internal*)__Instance) = *((global::ZLMediaKit.CodecArgs.Video.__Internal*)__0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public int Width
            {
                get
                {
                    return ((__Internal*)__Instance)->width;
                }

                set
                {
                    ((__Internal*)__Instance)->width = value;
                }
            }

            public int Height
            {
                get
                {
                    return ((__Internal*)__Instance)->height;
                }

                set
                {
                    ((__Internal*)__Instance)->height = value;
                }
            }

            public int Fps
            {
                get
                {
                    return ((__Internal*)__Instance)->fps;
                }

                set
                {
                    ((__Internal*)__Instance)->fps = value;
                }
            }
        }

        public unsafe partial class Audio : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal int channels;
                internal int sample_rate;

                [SuppressUnmanagedCodeSecurity, DllImport("ZLMediaKit", EntryPoint = "??0<unnamed-type-audio>@codec_args@@QEAA@AEBU01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern IntPtr cctor(IntPtr __instance, IntPtr __0);
            }

            public IntPtr __Instance { get; protected set; }

            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ZLMediaKit.CodecArgs.Audio> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ZLMediaKit.CodecArgs.Audio>();

            protected bool __ownsNativeInstance;

            internal static Audio __CreateInstance(IntPtr native, bool skipVTables = false)
            {
                return new Audio(native.ToPointer(), skipVTables);
            }

            internal static Audio __GetOrCreateInstance(IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == IntPtr.Zero)
                    return null;
                if (NativeToManagedMap.TryGetValue(native, out var managed))
                    return (Audio)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    NativeToManagedMap[native] = result;
                return result;
            }

            internal static Audio __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Audio(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*)ret = native;
                return ret.ToPointer();
            }

            private Audio(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected Audio(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new IntPtr(native);
            }

            public Audio()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::ZLMediaKit.CodecArgs.Audio.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public Audio(global::ZLMediaKit.CodecArgs.Audio __0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::ZLMediaKit.CodecArgs.Audio.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::ZLMediaKit.CodecArgs.Audio.__Internal*)__Instance) = *((global::ZLMediaKit.CodecArgs.Audio.__Internal*)__0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public int Channels
            {
                get
                {
                    return ((__Internal*)__Instance)->channels;
                }

                set
                {
                    ((__Internal*)__Instance)->channels = value;
                }
            }

            public int SampleRate
            {
                get
                {
                    return ((__Internal*)__Instance)->sample_rate;
                }

                set
                {
                    ((__Internal*)__Instance)->sample_rate = value;
                }
            }
        }

        private CodecArgs.__Internal __instance;
        internal CodecArgs.__Internal __Instance { get { return __instance; } }

        internal static CodecArgs __CreateInstance(IntPtr native, bool skipVTables = false)
        {
            return new CodecArgs(native.ToPointer(), skipVTables);
        }

        internal static CodecArgs __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CodecArgs(native, skipVTables);
        }

        private CodecArgs(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private CodecArgs(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::ZLMediaKit.CodecArgs.__Internal*)native;
        }

        public CodecArgs(global::ZLMediaKit.CodecArgs __0)
            : this()
        {
            var ____arg0 = __0.__Instance;
            var __arg0 = new IntPtr(&____arg0);
            fixed (__Internal* __instancePtr = &__instance)
            {
                __Internal.cctor(new IntPtr(__instancePtr), __arg0);
            }
        }

        public global::ZLMediaKit.CodecArgs.Video video
        {
            get
            {
                return global::ZLMediaKit.CodecArgs.Video.__CreateInstance(__instance.video);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.video = *(global::ZLMediaKit.CodecArgs.Video.__Internal*)value.__Instance;
            }
        }

        public global::ZLMediaKit.CodecArgs.Audio audio
        {
            get
            {
                return global::ZLMediaKit.CodecArgs.Audio.__CreateInstance(__instance.audio);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.audio = *(global::ZLMediaKit.CodecArgs.Audio.__Internal*)value.__Instance;
            }
        }
    }

    public unsafe partial class mk_track
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_track_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkTrackCreate(int codec_id, IntPtr args);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_track_unref", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkTrackUnref(IntPtr track);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_track_ref", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkTrackRef(IntPtr track);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_track_codec_id", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int MkTrackCodecId(IntPtr track);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_track_codec_name", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkTrackCodecName(IntPtr track);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_track_bit_rate", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int MkTrackBitRate(IntPtr track);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_track_add_delegate", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkTrackAddDelegate(IntPtr track, IntPtr cb, IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_track_del_delegate", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkTrackDelDelegate(IntPtr track, IntPtr tag);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_track_input_frame", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkTrackInputFrame(IntPtr track, IntPtr frame);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_track_is_video", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int MkTrackIsVideo(IntPtr track);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_track_video_width", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int MkTrackVideoWidth(IntPtr track);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_track_video_height", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int MkTrackVideoHeight(IntPtr track);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_track_video_fps", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int MkTrackVideoFps(IntPtr track);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_track_audio_sample_rate", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int MkTrackAudioSampleRate(IntPtr track);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_track_audio_channel", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int MkTrackAudioChannel(IntPtr track);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_track_audio_sample_bit", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int MkTrackAudioSampleBit(IntPtr track);
        }

        /// <summary>创建track对象引用</summary>
        /// <param name="codec_id">请参考MKCodecXXX 常量定义</param>
        /// <param name="args">视频或音频参数</param>
        /// <returns>track对象引用</returns>
        public static IntPtr MkTrackCreate(int codec_id, global::ZLMediaKit.CodecArgs args)
        {
            var ____arg1 = args.__Instance;
            var __arg1 = new IntPtr(&____arg1);
            var __ret = __Internal.MkTrackCreate(codec_id, __arg1);
            return __ret;
        }

        /// <summary>减引用track对象</summary>
        /// <param name="track">track对象</param>
        public static void MkTrackUnref(IntPtr track)
        {
            __Internal.MkTrackUnref(track);
        }

        /// <summary>引用track对象</summary>
        /// <param name="track">track对象</param>
        /// <returns>新的track引用对象</returns>
        public static IntPtr MkTrackRef(IntPtr track)
        {
            var __ret = __Internal.MkTrackRef(track);
            return __ret;
        }

        /// <summary>获取track 编码codec类型，请参考MKCodecXXX定义</summary>
        public static int MkTrackCodecId(IntPtr track)
        {
            var __ret = __Internal.MkTrackCodecId(track);
            return __ret;
        }

        /// <summary>获取编码codec名称</summary>
        public static string MkTrackCodecName(IntPtr track)
        {
            var __ret = __Internal.MkTrackCodecName(track);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        /// <summary>获取比特率信息</summary>
        public static int MkTrackBitRate(IntPtr track)
        {
            var __ret = __Internal.MkTrackBitRate(track);
            return __ret;
        }

        /// <summary>监听frame输出事件</summary>
        /// <param name="track">track对象</param>
        /// <param name="cb">frame输出回调</param>
        /// <param name="user_data">frame输出回调用户指针参数</param>
        public static IntPtr MkTrackAddDelegate(IntPtr track, global::ZLMediaKit.OnMkFrameOut cb, IntPtr user_data)
        {
            var __arg1 = cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cb);
            var __ret = __Internal.MkTrackAddDelegate(track, __arg1, user_data);
            return __ret;
        }

        /// <summary>取消frame输出事件监听</summary>
        /// <param name="track">track对象</param>
        /// <param name="tag">mk_track_add_delegate返回值</param>
        public static void MkTrackDelDelegate(IntPtr track, IntPtr tag)
        {
            __Internal.MkTrackDelDelegate(track, tag);
        }

        /// <summary>输入frame到track，通常你不需要调用此api</summary>
        public static void MkTrackInputFrame(IntPtr track, IntPtr frame)
        {
            __Internal.MkTrackInputFrame(track, frame);
        }

        /// <summary>track是否为视频</summary>
        public static int MkTrackIsVideo(IntPtr track)
        {
            var __ret = __Internal.MkTrackIsVideo(track);
            return __ret;
        }

        /// <summary>获取视频宽度</summary>
        public static int MkTrackVideoWidth(IntPtr track)
        {
            var __ret = __Internal.MkTrackVideoWidth(track);
            return __ret;
        }

        /// <summary>获取视频高度</summary>
        public static int MkTrackVideoHeight(IntPtr track)
        {
            var __ret = __Internal.MkTrackVideoHeight(track);
            return __ret;
        }

        /// <summary>获取视频帧率</summary>
        public static int MkTrackVideoFps(IntPtr track)
        {
            var __ret = __Internal.MkTrackVideoFps(track);
            return __ret;
        }

        /// <summary>获取音频采样率</summary>
        public static int MkTrackAudioSampleRate(IntPtr track)
        {
            var __ret = __Internal.MkTrackAudioSampleRate(track);
            return __ret;
        }

        /// <summary>获取音频通道数</summary>
        public static int MkTrackAudioChannel(IntPtr track)
        {
            var __ret = __Internal.MkTrackAudioChannel(track);
            return __ret;
        }

        /// <summary>获取音频位数，一般为16bit</summary>
        public static int MkTrackAudioSampleBit(IntPtr track)
        {
            var __ret = __Internal.MkTrackAudioSampleBit(track);
            return __ret;
        }
    }

    /// <summary>////////////////////////////////////////事件线程/////////////////////////////////////////////</summary>
    /// <summary>////////////////////////////////////////线程切换/////////////////////////////////////////////</summary>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void OnMkAsync(IntPtr user_data);

    /// <summary>////////////////////////////////////////定时器/////////////////////////////////////////////</summary>
    /// <summary>定时器触发事件</summary>
    /// <returns>下一次触发延时(单位毫秒)，返回0则不再重复</returns>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate ulong OnMkTimer(IntPtr user_data);

    /// <summary>////////////////////////////////////////信号量/////////////////////////////////////////////</summary>
    public unsafe partial class mk_thread
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_thread_from_tcp_session", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkThreadFromTcpSession(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_thread_from_tcp_client", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkThreadFromTcpClient(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_thread_from_pool", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkThreadFromPool();

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_thread_from_pool_work", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkThreadFromPoolWork();

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_thread_pool_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkThreadPoolCreate([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name, ulong n_thread, int priority);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_thread_pool_release", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int MkThreadPoolRelease(IntPtr pool);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_thread_from_thread_pool", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkThreadFromThreadPool(IntPtr pool);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_async_do", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkAsyncDo(IntPtr ctx, IntPtr cb, IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_async_do_delay", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkAsyncDoDelay(IntPtr ctx, ulong ms, IntPtr cb, IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_sync_do", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkSyncDo(IntPtr ctx, IntPtr cb, IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_timer_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkTimerCreate(IntPtr ctx, ulong delay_ms, IntPtr cb, IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_timer_release", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkTimerRelease(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_sem_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkSemCreate();

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_sem_release", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkSemRelease(IntPtr sem);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_sem_post", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkSemPost(IntPtr sem, ulong n);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_sem_wait", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkSemWait(IntPtr sem);
        }

        /// <summary>获取tcp会话对象所在事件线程</summary>
        /// <param name="ctx">tcp会话对象</param>
        /// <returns>对象所在事件线程</returns>
        public static IntPtr MkThreadFromTcpSession(IntPtr ctx)
        {
            var __ret = __Internal.MkThreadFromTcpSession(ctx);
            return __ret;
        }

        /// <summary>获取tcp客户端对象所在事件线程</summary>
        /// <param name="ctx">tcp客户端</param>
        /// <returns>对象所在事件线程</returns>
        public static IntPtr MkThreadFromTcpClient(IntPtr ctx)
        {
            var __ret = __Internal.MkThreadFromTcpClient(ctx);
            return __ret;
        }

        /// <summary>
        /// <para>根据负载均衡算法，从事件线程池中随机获取一个事件线程</para>
        /// <para>如果在事件线程内执行此函数将返回本事件线程</para>
        /// <para>事件线程指的是定时器、网络io事件线程</para>
        /// </summary>
        /// <returns>事件线程</returns>
        public static IntPtr MkThreadFromPool()
        {
            var __ret = __Internal.MkThreadFromPool();
            return __ret;
        }

        /// <summary>
        /// <para>根据负载均衡算法，从后台线程池中随机获取一个线程</para>
        /// <para>后台线程本质与事件线程相同，只是优先级更低，同时可以执行短时间的阻塞任务</para>
        /// <para>ZLMediaKit中后台线程用于dns解析、mp4点播时的文件解复用</para>
        /// </summary>
        /// <returns>后台线程</returns>
        public static IntPtr MkThreadFromPoolWork()
        {
            var __ret = __Internal.MkThreadFromPoolWork();
            return __ret;
        }

        /// <summary>创建线程池</summary>
        /// <param name="name">线程池名称，方便调试</param>
        /// <param name="n_thread">线程个数，0时为cpu个数</param>
        /// <param name="priority">线程优先级，分为PRIORITY_LOWEST = 0,PRIORITY_LOW, PRIORITY_NORMAL, PRIORITY_HIGH, PRIORITY_HIGHEST</param>
        /// <returns>线程池</returns>
        public static IntPtr MkThreadPoolCreate(string name, ulong n_thread, int priority)
        {
            var __ret = __Internal.MkThreadPoolCreate(name, n_thread, priority);
            return __ret;
        }

        /// <summary>销毁线程池</summary>
        /// <param name="pool">线程池</param>
        /// <returns>0:成功</returns>
        public static int MkThreadPoolRelease(IntPtr pool)
        {
            var __ret = __Internal.MkThreadPoolRelease(pool);
            return __ret;
        }

        /// <summary>从线程池获取一个线程</summary>
        /// <param name="pool">线程池</param>
        /// <returns>线程</returns>
        public static IntPtr MkThreadFromThreadPool(IntPtr pool)
        {
            var __ret = __Internal.MkThreadFromThreadPool(pool);
            return __ret;
        }

        /// <summary>切换到事件线程并异步执行</summary>
        /// <param name="ctx">事件线程</param>
        /// <param name="cb">回调函数</param>
        /// <param name="user_data">用户数据指针</param>
        public static void MkAsyncDo(IntPtr ctx, global::ZLMediaKit.OnMkAsync cb, IntPtr user_data)
        {
            var __arg1 = cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cb);
            __Internal.MkAsyncDo(ctx, __arg1, user_data);
        }

        /// <summary>切换到事件线程并延时执行</summary>
        /// <param name="ctx">事件线程</param>
        /// <param name="ms">延时时间，单位毫秒</param>
        /// <param name="cb">回调函数</param>
        /// <param name="user_data">用户数据指针</param>
        public static void MkAsyncDoDelay(IntPtr ctx, ulong ms, global::ZLMediaKit.OnMkAsync cb, IntPtr user_data)
        {
            var __arg2 = cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cb);
            __Internal.MkAsyncDoDelay(ctx, ms, __arg2, user_data);
        }

        /// <summary>切换到事件线程并同步执行</summary>
        /// <param name="ctx">事件线程</param>
        /// <param name="cb">回调函数</param>
        /// <param name="user_data">用户数据指针</param>
        public static void MkSyncDo(IntPtr ctx, global::ZLMediaKit.OnMkAsync cb, IntPtr user_data)
        {
            var __arg1 = cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cb);
            __Internal.MkSyncDo(ctx, __arg1, user_data);
        }

        /// <summary>创建定时器</summary>
        /// <param name="ctx">线程对象</param>
        /// <param name="delay_ms">执行延时，单位毫秒</param>
        /// <param name="cb">回调函数</param>
        /// <param name="user_data">用户数据指针</param>
        /// <returns>定时器对象</returns>
        public static IntPtr MkTimerCreate(IntPtr ctx, ulong delay_ms, global::ZLMediaKit.OnMkTimer cb, IntPtr user_data)
        {
            var __arg2 = cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cb);
            var __ret = __Internal.MkTimerCreate(ctx, delay_ms, __arg2, user_data);
            return __ret;
        }

        /// <summary>销毁和取消定时器</summary>
        /// <param name="ctx">定时器对象</param>
        public static void MkTimerRelease(IntPtr ctx)
        {
            __Internal.MkTimerRelease(ctx);
        }

        /// <summary>创建信号量</summary>
        public static IntPtr MkSemCreate()
        {
            var __ret = __Internal.MkSemCreate();
            return __ret;
        }

        /// <summary>销毁信号量</summary>
        public static void MkSemRelease(IntPtr sem)
        {
            __Internal.MkSemRelease(sem);
        }

        /// <summary>信号量加n</summary>
        public static void MkSemPost(IntPtr sem, ulong n)
        {
            __Internal.MkSemPost(sem, n);
        }

        /// <summary>信号量减1</summary>
        public static void MkSemWait(IntPtr sem)
        {
            __Internal.MkSemWait(sem);
        }
    }

    /// <summary>
    /// <para>MediaSource.close()回调事件</para>
    /// <para>在选择关闭一个关联的MediaSource时，将会最终触发到该回调</para>
    /// <para>你应该通过该事件调用mk_proxy_player_release函数并且释放其他资源</para>
    /// <para>如果你不调用mk_proxy_player_release函数，那么MediaSource.close()操作将无效</para>
    /// </summary>
    /// <param name="user_data">用户数据指针，通过mk_proxy_player_set_on_close函数设置</param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void OnMkProxyPlayerClose(IntPtr user_data, int err, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string what, int sys_err);

    public unsafe partial class mk_proxyplayer
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_proxy_player_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkProxyPlayerCreate([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string vhost, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string app, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string stream, int hls_enabled, int mp4_enabled);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_proxy_player_release", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkProxyPlayerRelease(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_proxy_player_set_option", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkProxyPlayerSetOption(IntPtr ctx, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string key, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string val);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_proxy_player_play", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkProxyPlayerPlay(IntPtr ctx, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string url);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_proxy_player_set_on_close", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkProxyPlayerSetOnClose(IntPtr ctx, IntPtr cb, IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_proxy_player_total_reader_count", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int MkProxyPlayerTotalReaderCount(IntPtr ctx);
        }

        /// <summary>创建一个代理播放器</summary>
        /// <param name="vhost">虚拟主机名，一般为__defaultVhost__</param>
        /// <param name="app">应用名</param>
        /// <param name="stream">流名</param>
        /// <param name="rtp_type">rtsp播放方式:RTP_TCP = 0, RTP_UDP = 1, RTP_MULTICAST = 2</param>
        /// <param name="hls_enabled">是否生成hls</param>
        /// <param name="mp4_enabled">是否生成mp4</param>
        /// <returns>对象指针</returns>
        public static IntPtr MkProxyPlayerCreate(string vhost, string app, string stream, int hls_enabled, int mp4_enabled)
        {
            var __ret = __Internal.MkProxyPlayerCreate(vhost, app, stream, hls_enabled, mp4_enabled);
            return __ret;
        }

        /// <summary>销毁代理播放器</summary>
        /// <param name="ctx">对象指针</param>
        public static void MkProxyPlayerRelease(IntPtr ctx)
        {
            __Internal.MkProxyPlayerRelease(ctx);
        }

        /// <summary>设置代理播放器配置选项</summary>
        /// <param name="ctx">代理播放器指针</param>
        /// <param name="key">配置项键,支持 net_adapter/rtp_type/rtsp_user/rtsp_pwd/protocol_timeout_ms/media_timeout_ms/beat_interval_ms</param>
        /// <param name="val">配置项值,如果是整形，需要转换成统一转换成string</param>
        public static void MkProxyPlayerSetOption(IntPtr ctx, string key, string val)
        {
            __Internal.MkProxyPlayerSetOption(ctx, key, val);
        }

        /// <summary>开始播放</summary>
        /// <param name="ctx">对象指针</param>
        /// <param name="url">播放url,支持rtsp/rtmp</param>
        public static void MkProxyPlayerPlay(IntPtr ctx, string url)
        {
            __Internal.MkProxyPlayerPlay(ctx, url);
        }

        /// <summary>
        /// <para>监听MediaSource.close()事件</para>
        /// <para>在选择关闭一个关联的MediaSource时，将会最终触发到该回调</para>
        /// <para>你应该通过该事件调用mk_proxy_player_release函数并且释放其他资源</para>
        /// </summary>
        /// <param name="ctx">对象指针</param>
        /// <param name="cb">回调指针</param>
        /// <param name="user_data">用户数据指针</param>
        public static void MkProxyPlayerSetOnClose(IntPtr ctx, global::ZLMediaKit.OnMkProxyPlayerClose cb, IntPtr user_data)
        {
            var __arg1 = cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cb);
            __Internal.MkProxyPlayerSetOnClose(ctx, __arg1, user_data);
        }

        /// <summary>获取总的观看人数</summary>
        /// <param name="ctx">对象指针</param>
        /// <returns>观看人数</returns>
        public static int MkProxyPlayerTotalReaderCount(IntPtr ctx)
        {
            var __ret = __Internal.MkProxyPlayerTotalReaderCount(ctx);
            return __ret;
        }
    }

    /// <summary>////////////////////////////////////////flv录制/////////////////////////////////////////////</summary>
    public unsafe partial class mk_recorder
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_flv_recorder_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkFlvRecorderCreate();

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_flv_recorder_release", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkFlvRecorderRelease(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_flv_recorder_start", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int MkFlvRecorderStart(IntPtr ctx, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string vhost, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string app, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string stream, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string file_path);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_recorder_is_recording", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int MkRecorderIsRecording(int type, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string vhost, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string app, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string stream);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_recorder_start", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int MkRecorderStart(int type, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string vhost, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string app, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string stream, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string customized_path, ulong max_second);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_recorder_stop", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int MkRecorderStop(int type, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string vhost, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string app, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string stream);
        }

        /// <summary>创建flv录制器</summary>
        public static IntPtr MkFlvRecorderCreate()
        {
            var __ret = __Internal.MkFlvRecorderCreate();
            return __ret;
        }

        /// <summary>释放flv录制器</summary>
        public static void MkFlvRecorderRelease(IntPtr ctx)
        {
            __Internal.MkFlvRecorderRelease(ctx);
        }

        /// <summary>开始录制flv</summary>
        /// <param name="ctx">flv录制器</param>
        /// <param name="vhost">虚拟主机</param>
        /// <param name="app">绑定的RtmpMediaSource的 app名</param>
        /// <param name="stream">绑定的RtmpMediaSource的 stream名</param>
        /// <param name="file_path">文件存放地址</param>
        /// <returns>0:开始超过，-1:失败,打开文件失败或该RtmpMediaSource不存在</returns>
        public static int MkFlvRecorderStart(IntPtr ctx, string vhost, string app, string stream, string file_path)
        {
            var __ret = __Internal.MkFlvRecorderStart(ctx, vhost, app, stream, file_path);
            return __ret;
        }

        /// <summary>获取录制状态</summary>
        /// <param name="type">0:hls,1:MP4</param>
        /// <param name="vhost">虚拟主机</param>
        /// <param name="app">应用名</param>
        /// <param name="stream">流id</param>
        /// <returns>录制状态,0:未录制, 1:正在录制</returns>
        public static int MkRecorderIsRecording(int type, string vhost, string app, string stream)
        {
            var __ret = __Internal.MkRecorderIsRecording(type, vhost, app, stream);
            return __ret;
        }

        /// <summary>开始录制</summary>
        /// <param name="type">0:hls,1:MP4</param>
        /// <param name="vhost">虚拟主机</param>
        /// <param name="app">应用名</param>
        /// <param name="stream">流id</param>
        /// <param name="customized_path">录像文件保存自定义目录，默认为空或null则自动生成</param>
        /// <param name="max_second">mp4录制最大切片时间，单位秒，置0则采用配置文件配置</param>
        /// <returns>1代表成功，0代表失败</returns>
        public static int MkRecorderStart(int type, string vhost, string app, string stream, string customized_path, ulong max_second)
        {
            var __ret = __Internal.MkRecorderStart(type, vhost, app, stream, customized_path, max_second);
            return __ret;
        }

        /// <summary>停止录制</summary>
        /// <param name="type">0:hls,1:MP4</param>
        /// <param name="vhost">虚拟主机</param>
        /// <param name="app">应用名</param>
        /// <param name="stream">流id</param>
        /// <returns>1:成功，0：失败</returns>
        public static int MkRecorderStop(int type, string vhost, string app, string stream)
        {
            var __ret = __Internal.MkRecorderStop(type, vhost, app, stream);
            return __ret;
        }
    }

    /// <summary>播放结果或播放中断事件的回调</summary>
    /// <param name="user_data">用户数据指针</param>
    /// <param name="err_code">错误代码，0为成功</param>
    /// <param name="err_msg">错误提示</param>
    /// <param name="tracks">track列表</param>
    /// <param name="track_count">track个数</param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void OnMkPlayEvent(IntPtr user_data, int err_code, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string err_msg, IntPtr[] tracks, int track_count);

    public unsafe partial class mk_player
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_player_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkPlayerCreate();

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_player_release", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkPlayerRelease(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_player_set_option", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkPlayerSetOption(IntPtr ctx, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string key, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string val);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_player_play", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkPlayerPlay(IntPtr ctx, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string url);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_player_pause", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkPlayerPause(IntPtr ctx, int pause);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_player_speed", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkPlayerSpeed(IntPtr ctx, float speed);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_player_seekto", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkPlayerSeekto(IntPtr ctx, float progress);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_player_seekto_pos", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkPlayerSeektoPos(IntPtr ctx, int seek_pos);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_player_set_on_result", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkPlayerSetOnResult(IntPtr ctx, IntPtr cb, IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_player_set_on_shutdown", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkPlayerSetOnShutdown(IntPtr ctx, IntPtr cb, IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_player_duration", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern float MkPlayerDuration(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_player_progress", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern float MkPlayerProgress(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_player_progress_pos", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int MkPlayerProgressPos(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_player_loss_rate", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern float MkPlayerLossRate(IntPtr ctx, int track_type);
        }

        /// <summary>创建一个播放器,支持rtmp[s]/rtsp[s]</summary>
        /// <returns>播放器指针</returns>
        public static IntPtr MkPlayerCreate()
        {
            var __ret = __Internal.MkPlayerCreate();
            return __ret;
        }

        /// <summary>销毁播放器</summary>
        /// <param name="ctx">播放器指针</param>
        public static void MkPlayerRelease(IntPtr ctx)
        {
            __Internal.MkPlayerRelease(ctx);
        }

        /// <summary>设置播放器配置选项</summary>
        /// <param name="ctx">播放器指针</param>
        /// <param name="key">配置项键,支持 net_adapter/rtp_type/rtsp_user/rtsp_pwd/protocol_timeout_ms/media_timeout_ms/beat_interval_ms/wait_track_ready</param>
        /// <param name="val">配置项值,如果是整形，需要转换成统一转换成string</param>
        public static void MkPlayerSetOption(IntPtr ctx, string key, string val)
        {
            __Internal.MkPlayerSetOption(ctx, key, val);
        }

        /// <summary>开始播放url</summary>
        /// <param name="ctx">播放器指针</param>
        /// <param name="url">rtsp[s]/rtmp[s] url</param>
        public static void MkPlayerPlay(IntPtr ctx, string url)
        {
            __Internal.MkPlayerPlay(ctx, url);
        }

        /// <summary>暂停或恢复播放，仅对点播有用</summary>
        /// <param name="ctx">播放器指针</param>
        /// <param name="pause">1:暂停播放，0：恢复播放</param>
        public static void MkPlayerPause(IntPtr ctx, int pause)
        {
            __Internal.MkPlayerPause(ctx, pause);
        }

        /// <summary>倍数播放，仅对点播有用</summary>
        /// <param name="ctx">播放器指针</param>
        /// <param name="speed">0.5 1.0 2.0</param>
        public static void MkPlayerSpeed(IntPtr ctx, float speed)
        {
            __Internal.MkPlayerSpeed(ctx, speed);
        }

        /// <summary>设置点播进度条</summary>
        /// <param name="ctx">对象指针</param>
        /// <param name="progress">取值范围未 0.0～1.0</param>
        public static void MkPlayerSeekto(IntPtr ctx, float progress)
        {
            __Internal.MkPlayerSeekto(ctx, progress);
        }

        /// <summary>设置点播进度条</summary>
        /// <param name="ctx">对象指针</param>
        /// <param name="seek_pos">取值范围 相对于开始时间增量 单位秒</param>
        public static void MkPlayerSeektoPos(IntPtr ctx, int seek_pos)
        {
            __Internal.MkPlayerSeektoPos(ctx, seek_pos);
        }

        /// <summary>设置播放器开启播放结果回调函数</summary>
        /// <param name="ctx">播放器指针</param>
        /// <param name="cb">回调函数指针,设置null立即取消回调</param>
        /// <param name="user_data">用户数据指针</param>
        public static void MkPlayerSetOnResult(IntPtr ctx, global::ZLMediaKit.OnMkPlayEvent cb, IntPtr user_data)
        {
            var __arg1 = cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cb);
            __Internal.MkPlayerSetOnResult(ctx, __arg1, user_data);
        }

        /// <summary>设置播放被异常中断的回调</summary>
        /// <param name="ctx">播放器指针</param>
        /// <param name="cb">回调函数指针,设置null立即取消回调</param>
        /// <param name="user_data">用户数据指针</param>
        public static void MkPlayerSetOnShutdown(IntPtr ctx, global::ZLMediaKit.OnMkPlayEvent cb, IntPtr user_data)
        {
            var __arg1 = cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cb);
            __Internal.MkPlayerSetOnShutdown(ctx, __arg1, user_data);
        }

        /// <summary>获取点播节目时长，如果是直播返回0，否则返回秒数</summary>
        public static float MkPlayerDuration(IntPtr ctx)
        {
            var __ret = __Internal.MkPlayerDuration(ctx);
            return __ret;
        }

        /// <summary>获取点播播放进度，取值范围 0.0～1.0</summary>
        public static float MkPlayerProgress(IntPtr ctx)
        {
            var __ret = __Internal.MkPlayerProgress(ctx);
            return __ret;
        }

        /// <summary>获取点播播放进度位置，取值范围 相对于开始时间增量 单位秒</summary>
        public static int MkPlayerProgressPos(IntPtr ctx)
        {
            var __ret = __Internal.MkPlayerProgressPos(ctx);
            return __ret;
        }

        /// <summary>获取丢包率，rtsp时有效</summary>
        /// <param name="ctx">对象指针</param>
        /// <param name="track_type">0：视频，1：音频</param>
        public static float MkPlayerLossRate(IntPtr ctx, int track_type)
        {
            var __ret = __Internal.MkPlayerLossRate(ctx, track_type);
            return __ret;
        }
    }

    /// <summary>推流结果或推流中断事件的回调</summary>
    /// <param name="user_data">用户数据指针</param>
    /// <param name="err_code">错误代码，0为成功</param>
    /// <param name="err_msg">错误提示</param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void OnMkPushEvent(IntPtr user_data, int err_code, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string err_msg);

    public unsafe partial class mk_pusher
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_pusher_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkPusherCreate([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string schema, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string vhost, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string app, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string stream);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_pusher_create_src", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkPusherCreateSrc(IntPtr src);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_pusher_release", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkPusherRelease(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_pusher_set_option", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkPusherSetOption(IntPtr ctx, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string key, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string val);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_pusher_publish", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkPusherPublish(IntPtr ctx, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string url);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_pusher_set_on_result", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkPusherSetOnResult(IntPtr ctx, IntPtr cb, IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_pusher_set_on_shutdown", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkPusherSetOnShutdown(IntPtr ctx, IntPtr cb, IntPtr user_data);
        }

        /// <summary>
        /// <para>绑定的MediaSource对象并创建rtmp[s]/rtsp[s]推流器</para>
        /// <para>MediaSource通过mk_media_create或mk_proxy_player_create或推流生成</para>
        /// <para>该MediaSource对象必须已注册</para>
        /// </summary>
        /// <param name="schema">绑定的MediaSource对象所属协议，支持rtsp/rtmp</param>
        /// <param name="vhost">绑定的MediaSource对象的虚拟主机，一般为__defaultVhost__</param>
        /// <param name="app">绑定的MediaSource对象的应用名，一般为live</param>
        /// <param name="stream">绑定的MediaSource对象的流id</param>
        /// <returns>对象指针</returns>
        public static IntPtr MkPusherCreate(string schema, string vhost, string app, string stream)
        {
            var __ret = __Internal.MkPusherCreate(schema, vhost, app, stream);
            return __ret;
        }

        /// <summary>
        /// <para>绑定的MediaSource对象并创建rtmp[s]/rtsp[s]推流器</para>
        /// <para>MediaSource通过mk_media_create或mk_proxy_player_create或推流生成</para>
        /// <para>该MediaSource对象必须已注册</para>
        /// </summary>
        /// <param name="src">MediaSource对象</param>
        /// <returns>对象指针</returns>
        public static IntPtr MkPusherCreateSrc(IntPtr src)
        {
            var __ret = __Internal.MkPusherCreateSrc(src);
            return __ret;
        }

        /// <summary>释放推流器</summary>
        /// <param name="ctx">推流器指针</param>
        public static void MkPusherRelease(IntPtr ctx)
        {
            __Internal.MkPusherRelease(ctx);
        }

        /// <summary>设置推流器配置选项</summary>
        /// <param name="ctx">推流器指针</param>
        /// <param name="key">配置项键,支持 net_adapter/rtp_type/rtsp_user/rtsp_pwd/protocol_timeout_ms/media_timeout_ms/beat_interval_ms</param>
        /// <param name="val">配置项值,如果是整形，需要转换成统一转换成string</param>
        public static void MkPusherSetOption(IntPtr ctx, string key, string val)
        {
            __Internal.MkPusherSetOption(ctx, key, val);
        }

        /// <summary>开始推流</summary>
        /// <param name="ctx">推流器指针</param>
        /// <param name="url">推流地址，支持rtsp[s]/rtmp[s]</param>
        public static void MkPusherPublish(IntPtr ctx, string url)
        {
            __Internal.MkPusherPublish(ctx, url);
        }

        /// <summary>设置推流器推流结果回调函数</summary>
        /// <param name="ctx">推流器指针</param>
        /// <param name="cb">回调函数指针,不得为null</param>
        /// <param name="user_data">用户数据指针</param>
        public static void MkPusherSetOnResult(IntPtr ctx, global::ZLMediaKit.OnMkPushEvent cb, IntPtr user_data)
        {
            var __arg1 = cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cb);
            __Internal.MkPusherSetOnResult(ctx, __arg1, user_data);
        }

        /// <summary>设置推流被异常中断的回调</summary>
        /// <param name="ctx">推流器指针</param>
        /// <param name="cb">回调函数指针,不得为null</param>
        /// <param name="user_data">用户数据指针</param>
        public static void MkPusherSetOnShutdown(IntPtr ctx, global::ZLMediaKit.OnMkPushEvent cb, IntPtr user_data)
        {
            var __arg1 = cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cb);
            __Internal.MkPusherSetOnShutdown(ctx, __arg1, user_data);
        }
    }

    public unsafe partial class mk_util
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_util_get_exe_path", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern sbyte* MkUtilGetExePath();

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_util_get_exe_dir", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern sbyte* MkUtilGetExeDir([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string relative_path);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_util_get_current_millisecond", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ulong MkUtilGetCurrentMillisecond();

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_util_get_current_time_string", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern sbyte* MkUtilGetCurrentTimeString([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_util_hex_dump", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern sbyte* MkUtilHexDump(IntPtr buf, int len);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_log_printf", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkLogPrintf(int level, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string file, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string function, int line, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);
        }

        /// <summary>获取本程序可执行文件路径</summary>
        /// <returns>文件路径，使用完后需要自己free</returns>
        public static sbyte* MkUtilGetExePath()
        {
            var __ret = __Internal.MkUtilGetExePath();
            return __ret;
        }

        /// <summary>获取本程序可执行文件相同目录下文件的绝对路径</summary>
        /// <param name="relative_path">同目录下文件的路径相对,可以为null</param>
        /// <returns>文件路径，使用完后需要自己free</returns>
        public static sbyte* MkUtilGetExeDir(string relative_path)
        {
            var __ret = __Internal.MkUtilGetExeDir(relative_path);
            return __ret;
        }

        /// <summary>获取unix标准的系统时间戳</summary>
        /// <returns>当前系统时间戳</returns>
        public static ulong MkUtilGetCurrentMillisecond()
        {
            var __ret = __Internal.MkUtilGetCurrentMillisecond();
            return __ret;
        }

        /// <summary>获取时间字符串</summary>
        /// <param name="fmt">时间格式，譬如%Y-%m-%d %H:%M:%S</param>
        /// <returns>时间字符串，使用完后需要自己free</returns>
        public static sbyte* MkUtilGetCurrentTimeString(string fmt)
        {
            var __ret = __Internal.MkUtilGetCurrentTimeString(fmt);
            return __ret;
        }

        /// <summary>打印二进制为字符串</summary>
        /// <param name="buf">二进制数据</param>
        /// <param name="len">数据长度</param>
        /// <returns>可打印的调试信息，使用完后需要自己free</returns>
        public static sbyte* MkUtilHexDump(IntPtr buf, int len)
        {
            var __ret = __Internal.MkUtilHexDump(buf, len);
            return __ret;
        }

        /// <summary>打印日志</summary>
        /// <param name="level">日志级别,支持0~4</param>
        /// <param name="file">__FILE__</param>
        /// <param name="function">__FUNCTION__</param>
        /// <param name="line">__LINE__</param>
        /// <param name="fmt">printf类型的格式控制字符串</param>
        /// <param name="...">不定长参数</param>
        public static void MkLogPrintf(int level, string file, string function, int line, string fmt)
        {
            __Internal.MkLogPrintf(level, file, function, line, fmt);
        }
    }

    /// <summary>TCP 主动模式时连接到服务器是否成功的回调</summary>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void OnMkRtpServerConnected(IntPtr user_data, int err, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string what, int sys_err);

    /// <summary>GB28181 RTP 服务器接收流超时时触发</summary>
    /// <param name="user_data">用户数据指针</param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void OnMkRtpServerDetach(IntPtr user_data);

    public unsafe partial class mk_rtp_server
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_rtp_server_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkRtpServerCreate(ushort port, int tcp_mode, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string stream_id);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_rtp_server_connect", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkRtpServerConnect(IntPtr ctx, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string dst_url, ushort dst_port, IntPtr cb, IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_rtp_server_release", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkRtpServerRelease(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_rtp_server_port", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ushort MkRtpServerPort(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport(Constants.ApiDll, EntryPoint = "mk_rtp_server_set_on_detach", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkRtpServerSetOnDetach(IntPtr ctx, IntPtr cb, IntPtr user_data);
        }

        /// <summary>创建GB28181 RTP 服务器</summary>
        /// <param name="port">监听端口，0则为随机</param>
        /// <param name="tcp_mode">tcp模式(0: 不监听端口 1: 监听端口 2: 主动连接到服务端)</param>
        /// <param name="stream_id">该端口绑定的流id</param>
        public static IntPtr MkRtpServerCreate(ushort port, int tcp_mode, string stream_id)
        {
            var __ret = __Internal.MkRtpServerCreate(port, tcp_mode, stream_id);
            return __ret;
        }

        /// <summary>TCP 主动模式时连接到服务器</summary>
        /// <param name="ctx">服务器对象</param>
        /// <param name="dst_url">服务端地址</param>
        /// <param name="dst_port">服务端端口</param>
        /// <param name="cb">连接到服务器是否成功的回调</param>
        /// <param name="user_data">用户数据指针</param>
        public static void MkRtpServerConnect(IntPtr ctx, string dst_url, ushort dst_port, global::ZLMediaKit.OnMkRtpServerConnected cb, IntPtr user_data)
        {
            var __arg3 = cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cb);
            __Internal.MkRtpServerConnect(ctx, dst_url, dst_port, __arg3, user_data);
        }

        /// <summary>销毁GB28181 RTP 服务器</summary>
        /// <param name="ctx">服务器对象</param>
        public static void MkRtpServerRelease(IntPtr ctx)
        {
            __Internal.MkRtpServerRelease(ctx);
        }

        /// <summary>获取本地监听的端口号</summary>
        /// <param name="ctx">服务器对象</param>
        /// <returns>端口号</returns>
        public static ushort MkRtpServerPort(IntPtr ctx)
        {
            var __ret = __Internal.MkRtpServerPort(ctx);
            return __ret;
        }

        /// <summary>监听B28181 RTP 服务器接收流超时事件</summary>
        /// <param name="ctx">服务器对象</param>
        /// <param name="cb">回调函数</param>
        /// <param name="user_data">回调函数用户数据指针</param>
        public static void MkRtpServerSetOnDetach(IntPtr ctx, global::ZLMediaKit.OnMkRtpServerDetach cb, IntPtr user_data)
        {
            var __arg1 = cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cb);
            __Internal.MkRtpServerSetOnDetach(ctx, __arg1, user_data);
        }
    }

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void OnMkDecode(IntPtr user_data, IntPtr frame);

    public unsafe partial class AVFrame
    {
        public partial struct __Internal
        {
        }

        public IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ZLMediaKit.AVFrame> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ZLMediaKit.AVFrame>();

        protected bool __ownsNativeInstance;

        internal static AVFrame __CreateInstance(IntPtr native, bool skipVTables = false)
        {
            return new AVFrame(native.ToPointer(), skipVTables);
        }

        internal static AVFrame __GetOrCreateInstance(IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (AVFrame)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static AVFrame __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new AVFrame(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private AVFrame(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected AVFrame(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new IntPtr(native);
        }
    }

    public unsafe partial class AVCodecContext
    {
        public partial struct __Internal
        {
        }

        public IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ZLMediaKit.AVCodecContext> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ZLMediaKit.AVCodecContext>();

        protected bool __ownsNativeInstance;

        internal static AVCodecContext __CreateInstance(IntPtr native, bool skipVTables = false)
        {
            return new AVCodecContext(native.ToPointer(), skipVTables);
        }

        internal static AVCodecContext __GetOrCreateInstance(IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (AVCodecContext)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static AVCodecContext __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new AVCodecContext(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private AVCodecContext(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected AVCodecContext(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new IntPtr(native);
        }
    }

    public unsafe partial class mk_transcode
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("ZLMediaKit", EntryPoint = "mk_decoder_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkDecoderCreate(IntPtr track, int thread_num);

            [SuppressUnmanagedCodeSecurity, DllImport("ZLMediaKit", EntryPoint = "mk_decoder_release", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkDecoderRelease(IntPtr ctx, int flush_frame);

            [SuppressUnmanagedCodeSecurity, DllImport("ZLMediaKit", EntryPoint = "mk_decoder_decode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkDecoderDecode(IntPtr ctx, IntPtr frame, int async, int enable_merge);

            [SuppressUnmanagedCodeSecurity, DllImport("ZLMediaKit", EntryPoint = "mk_decoder_set_max_async_frame_size", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkDecoderSetMaxAsyncFrameSize(IntPtr ctx, ulong size);

            [SuppressUnmanagedCodeSecurity, DllImport("ZLMediaKit", EntryPoint = "mk_decoder_set_cb", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkDecoderSetCb(IntPtr ctx, IntPtr cb, IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport("ZLMediaKit", EntryPoint = "mk_decoder_get_context", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkDecoderGetContext(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport("ZLMediaKit", EntryPoint = "mk_frame_pix_ref", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkFramePixRef(IntPtr frame);

            [SuppressUnmanagedCodeSecurity, DllImport("ZLMediaKit", EntryPoint = "mk_frame_pix_unref", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkFramePixUnref(IntPtr frame);

            [SuppressUnmanagedCodeSecurity, DllImport("ZLMediaKit", EntryPoint = "mk_frame_pix_from_av_frame", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkFramePixFromAvFrame(IntPtr frame);

            [SuppressUnmanagedCodeSecurity, DllImport("ZLMediaKit", EntryPoint = "mk_frame_pix_get_av_frame", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkFramePixGetAvFrame(IntPtr frame);

            [SuppressUnmanagedCodeSecurity, DllImport("ZLMediaKit", EntryPoint = "mk_swscale_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkSwscaleCreate(int output, int width, int height);

            [SuppressUnmanagedCodeSecurity, DllImport("ZLMediaKit", EntryPoint = "mk_swscale_release", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MkSwscaleRelease(IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport("ZLMediaKit", EntryPoint = "mk_swscale_input_frame", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int MkSwscaleInputFrame(IntPtr ctx, IntPtr frame, byte* @out);

            [SuppressUnmanagedCodeSecurity, DllImport("ZLMediaKit", EntryPoint = "mk_swscale_input_frame2", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern IntPtr MkSwscaleInputFrame2(IntPtr ctx, IntPtr frame);

            [SuppressUnmanagedCodeSecurity, DllImport("ZLMediaKit", EntryPoint = "mk_get_av_frame_data", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte** MkGetAvFrameData(IntPtr frame);

            [SuppressUnmanagedCodeSecurity, DllImport("ZLMediaKit", EntryPoint = "mk_get_av_frame_line_size", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int* MkGetAvFrameLineSize(IntPtr frame);

            [SuppressUnmanagedCodeSecurity, DllImport("ZLMediaKit", EntryPoint = "mk_get_av_frame_dts", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern long MkGetAvFrameDts(IntPtr frame);

            [SuppressUnmanagedCodeSecurity, DllImport("ZLMediaKit", EntryPoint = "mk_get_av_frame_pts", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern long MkGetAvFramePts(IntPtr frame);

            [SuppressUnmanagedCodeSecurity, DllImport("ZLMediaKit", EntryPoint = "mk_get_av_frame_width", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int MkGetAvFrameWidth(IntPtr frame);

            [SuppressUnmanagedCodeSecurity, DllImport("ZLMediaKit", EntryPoint = "mk_get_av_frame_height", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int MkGetAvFrameHeight(IntPtr frame);

            [SuppressUnmanagedCodeSecurity, DllImport("ZLMediaKit", EntryPoint = "mk_get_av_frame_format", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int MkGetAvFrameFormat(IntPtr frame);
        }

        /// <summary>创建解码器</summary>
        /// <param name="track">track对象</param>
        /// <param name="thread_num">解码线程数，0时为自动</param>
        /// <returns>返回解码器对象，NULL代表失败</returns>
        public static IntPtr MkDecoderCreate(IntPtr track, int thread_num)
        {
            var __ret = __Internal.MkDecoderCreate(track, thread_num);
            return __ret;
        }

        /// <summary>销毁解码器</summary>
        /// <param name="ctx">解码器对象</param>
        /// <param name="flush_frame">是否等待所有帧解码成功</param>
        public static void MkDecoderRelease(IntPtr ctx, int flush_frame)
        {
            __Internal.MkDecoderRelease(ctx, flush_frame);
        }

        /// <summary>解码音视频帧</summary>
        /// <param name="ctx">解码器</param>
        /// <param name="frame">帧对象</param>
        /// <param name="async">是否异步解码</param>
        /// <param name="enable_merge">是否合并帧解码，有些情况下，需要把时间戳相同的slice合并输入到解码器才能解码</param>
        public static void MkDecoderDecode(IntPtr ctx, IntPtr frame, int async, int enable_merge)
        {
            __Internal.MkDecoderDecode(ctx, frame, async, enable_merge);
        }

        /// <summary>设置异步解码最大帧缓存积压数限制</summary>
        public static void MkDecoderSetMaxAsyncFrameSize(IntPtr ctx, ulong size)
        {
            __Internal.MkDecoderSetMaxAsyncFrameSize(ctx, size);
        }

        /// <summary>设置解码输出回调</summary>
        /// <param name="ctx">解码器</param>
        /// <param name="cb">回调函数</param>
        /// <param name="user_data">回调函数用户指针参数</param>
        public static void MkDecoderSetCb(IntPtr ctx, global::ZLMediaKit.OnMkDecode cb, IntPtr user_data)
        {
            var __arg1 = cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cb);
            __Internal.MkDecoderSetCb(ctx, __arg1, user_data);
        }

        /// <summary>获取FFmpeg原始AVCodecContext对象</summary>
        /// <param name="ctx">解码器</param>
        public static global::ZLMediaKit.AVCodecContext MkDecoderGetContext(IntPtr ctx)
        {
            var __ret = __Internal.MkDecoderGetContext(ctx);
            var __result0 = global::ZLMediaKit.AVCodecContext.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>创建解码帧mk_frame_pix新引用</summary>
        /// <param name="frame">原始引用</param>
        /// <returns>新引用</returns>
        public static IntPtr MkFramePixRef(IntPtr frame)
        {
            var __ret = __Internal.MkFramePixRef(frame);
            return __ret;
        }

        /// <summary>解码帧mk_frame_pix减引用</summary>
        /// <param name="frame">原始引用</param>
        public static void MkFramePixUnref(IntPtr frame)
        {
            __Internal.MkFramePixUnref(frame);
        }

        /// <summary>从FFmpeg AVFrame转换为mk_frame_pix</summary>
        /// <param name="frame">FFmpeg AVFrame</param>
        /// <returns>mk_frame_pix对象</returns>
        public static IntPtr MkFramePixFromAvFrame(global::ZLMediaKit.AVFrame frame)
        {
            var __arg0 = frame is null ? IntPtr.Zero : frame.__Instance;
            var __ret = __Internal.MkFramePixFromAvFrame(__arg0);
            return __ret;
        }

        /// <summary>获取FFmpeg AVFrame对象</summary>
        /// <param name="frame">解码帧mk_frame_pix</param>
        /// <returns>FFmpeg AVFrame对象</returns>
        public static global::ZLMediaKit.AVFrame MkFramePixGetAvFrame(IntPtr frame)
        {
            var __ret = __Internal.MkFramePixGetAvFrame(frame);
            var __result0 = global::ZLMediaKit.AVFrame.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>创建ffmpeg SwsContext wrapper实例</summary>
        /// <param name="output">AVPixelFormat类型，AV_PIX_FMT_BGR24==3</param>
        /// <param name="width">目标宽度，置0时，则与输入时一致</param>
        /// <param name="height">目标高度，置0时，则与输入时一致</param>
        /// <returns>SwsContext wrapper 实例</returns>
        public static IntPtr MkSwscaleCreate(int output, int width, int height)
        {
            var __ret = __Internal.MkSwscaleCreate(output, width, height);
            return __ret;
        }

        /// <summary>释放ffmpeg SwsContext wrapper实例</summary>
        /// <param name="ctx">SwsContext wrapper实例</param>
        public static void MkSwscaleRelease(IntPtr ctx)
        {
            __Internal.MkSwscaleRelease(ctx);
        }

        /// <summary>使用SwsContext转换pix format</summary>
        /// <param name="ctx">SwsContext wrapper实例</param>
        /// <param name="frame">pix frame</param>
        /// <param name="out">转换后存放的数据指针，用户需要确保提前申请并大小足够</param>
        /// <returns>sws_scale()返回值：the height of the output slice</returns>
        public static int MkSwscaleInputFrame(IntPtr ctx, IntPtr frame, byte* @out)
        {
            var __ret = __Internal.MkSwscaleInputFrame(ctx, frame, @out);
            return __ret;
        }

        /// <summary>使用SwsContext转换pix format</summary>
        /// <param name="ctx">SwsContext wrapper实例</param>
        /// <param name="frame">pix frame</param>
        /// <returns>新的pix frame对象，需要使用mk_frame_pix_unref销毁</returns>
        public static IntPtr MkSwscaleInputFrame2(IntPtr ctx, IntPtr frame)
        {
            var __ret = __Internal.MkSwscaleInputFrame2(ctx, frame);
            return __ret;
        }

        /// <summary>//////////////////////////////////////////////////////////////////////////////////////////</summary>
        public static byte** MkGetAvFrameData(global::ZLMediaKit.AVFrame frame)
        {
            var __arg0 = frame is null ? IntPtr.Zero : frame.__Instance;
            var __ret = __Internal.MkGetAvFrameData(__arg0);
            return __ret;
        }

        public static int* MkGetAvFrameLineSize(global::ZLMediaKit.AVFrame frame)
        {
            var __arg0 = frame is null ? IntPtr.Zero : frame.__Instance;
            var __ret = __Internal.MkGetAvFrameLineSize(__arg0);
            return __ret;
        }

        public static long MkGetAvFrameDts(global::ZLMediaKit.AVFrame frame)
        {
            var __arg0 = frame is null ? IntPtr.Zero : frame.__Instance;
            var __ret = __Internal.MkGetAvFrameDts(__arg0);
            return __ret;
        }

        public static long MkGetAvFramePts(global::ZLMediaKit.AVFrame frame)
        {
            var __arg0 = frame is null ? IntPtr.Zero : frame.__Instance;
            var __ret = __Internal.MkGetAvFramePts(__arg0);
            return __ret;
        }

        public static int MkGetAvFrameWidth(global::ZLMediaKit.AVFrame frame)
        {
            var __arg0 = frame is null ? IntPtr.Zero : frame.__Instance;
            var __ret = __Internal.MkGetAvFrameWidth(__arg0);
            return __ret;
        }

        public static int MkGetAvFrameHeight(global::ZLMediaKit.AVFrame frame)
        {
            var __arg0 = frame is null ? IntPtr.Zero : frame.__Instance;
            var __ret = __Internal.MkGetAvFrameHeight(__arg0);
            return __ret;
        }

        public static int MkGetAvFrameFormat(global::ZLMediaKit.AVFrame frame)
        {
            var __arg0 = frame is null ? IntPtr.Zero : frame.__Instance;
            var __ret = __Internal.MkGetAvFrameFormat(__arg0);
            return __ret;
        }
    }

    namespace Delegates
    {
        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action_int___IntPtr(int regist, IntPtr sender);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr___IntPtr___IntPtr(IntPtr url_info, IntPtr invoker, IntPtr sender);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate int Func_int___IntPtr___IntPtr(IntPtr url_info, IntPtr sender);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr(IntPtr sender);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr___IntPtr_intPtr___IntPtr(IntPtr parser, IntPtr invoker, int* consumed, IntPtr sender);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr_string8_int___IntPtr___IntPtr(IntPtr parser, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string path, int is_dir, IntPtr invoker, IntPtr sender);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr_sbytePtr___IntPtr(IntPtr parser, sbyte* path, IntPtr sender);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr_string8_string8_int___IntPtr___IntPtr(IntPtr url_info, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string realm, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string user_name, int must_no_encrypt, IntPtr invoker, IntPtr sender);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action_string8_string8___IntPtr___IntPtr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string user_name, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string passwd, IntPtr invoker, IntPtr sender);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr_ulong_ulong_int___IntPtr(IntPtr url_info, ulong total_bytes, ulong total_seconds, int is_player, IntPtr sender);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action_int_string8_int_string8_string8(int level, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string file, int line, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string function, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string message);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action_ushort___IntPtr(ushort server_port, IntPtr session);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action_ushort___IntPtr___IntPtr(ushort server_port, IntPtr session, IntPtr buffer);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action_ushort___IntPtr_int_string8(ushort server_port, IntPtr session, int code, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string msg);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr_int_string8(IntPtr client, int code, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string msg);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr___IntPtr(IntPtr client, IntPtr buffer);
    }
}
namespace ZLMediaKit.__Symbols
{
    internal class mk_api
    {
        public static IntPtr _MKCodecH264 { get; }
        public static IntPtr _MKCodecH265 { get; }
        public static IntPtr _MKCodecAAC { get; }
        public static IntPtr _MKCodecG711A { get; }
        public static IntPtr _MKCodecG711U { get; }
        public static IntPtr _MKCodecOpus { get; }
        public static IntPtr _MKCodecL16 { get; }
        public static IntPtr _MKCodecVP8 { get; }
        public static IntPtr _MKCodecVP9 { get; }
        public static IntPtr _MKCodecAV1 { get; }
        public static IntPtr _MKCodecJPEG { get; }
        static mk_api()
        {
            var path = Constants.ApiDll;
            var image = CppSharp.SymbolResolver.LoadImage(ref path);
            if (image == IntPtr.Zero) throw new global::System.DllNotFoundException(path);
            _MKCodecH264 = CppSharp.SymbolResolver.ResolveSymbol(image, "MKCodecH264");
            _MKCodecH265 = CppSharp.SymbolResolver.ResolveSymbol(image, "MKCodecH265");
            _MKCodecAAC = CppSharp.SymbolResolver.ResolveSymbol(image, "MKCodecAAC");
            _MKCodecG711A = CppSharp.SymbolResolver.ResolveSymbol(image, "MKCodecG711A");
            _MKCodecG711U = CppSharp.SymbolResolver.ResolveSymbol(image, "MKCodecG711U");
            _MKCodecOpus = CppSharp.SymbolResolver.ResolveSymbol(image, "MKCodecOpus");
            _MKCodecL16 = CppSharp.SymbolResolver.ResolveSymbol(image, "MKCodecL16");
            _MKCodecVP8 = CppSharp.SymbolResolver.ResolveSymbol(image, "MKCodecVP8");
            _MKCodecVP9 = CppSharp.SymbolResolver.ResolveSymbol(image, "MKCodecVP9");
            _MKCodecAV1 = CppSharp.SymbolResolver.ResolveSymbol(image, "MKCodecAV1");
            _MKCodecJPEG = CppSharp.SymbolResolver.ResolveSymbol(image, "MKCodecJPEG");
        }
    }
}
